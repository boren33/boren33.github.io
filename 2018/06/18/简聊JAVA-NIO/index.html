<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="如果批评不自由，赞美将毫无意义"><title>简聊JAVA NIO | boren's blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">简聊JAVA NIO</h1><a id="logo" href="/.">boren's blog</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 所有文章</i></a><a href="/about/"><i class="fa fa-user"> 关于作者</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">简聊JAVA NIO</h1><div class="post-meta">Jun 18, 2018<span> | </span><span class="category"><a href="/categories/技术人生/">技术人生</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><div class="post-content"><p>java NIO（non blocking IO），是一种同步非阻塞IO，为IO多路复用的基础，适用于高并发与大量连接，主要由三大组件构成：channel、Buffer、Selector，虽然还有一些其他组件，如管道，但大多是基于这三大组件而构造的。</p>
<h1><span id="channel">channel</span></h1><p>  与java BIO 数据流单向传输不同的是，NIO中引入了channel，它可以双向传输，既可以将数据通过缓冲写入到channel中，也可以将channel中的数据读入缓存。常见的channel类型有</p>
<p>  FileChannel（阻塞，无法结合selector使用）<br>  DatagramChannel<br>  SocketChannel<br>  ServerSocketChannel</p>
<h1><span id="buffer">Buffer</span></h1><p>   缓冲Buffer容易理解，就是把读取到的数据放入一个或多个池中，等池子满了，可以一次拿走；或者将数据分别放到不同的池中，一次性传输到channel中。而不必多次运输。<br>   Buffer中有四个属性：mark、capacity、position、limit。</p>
<p>  <img src="/2018/06/18/简聊JAVA-NIO/images/buffer.png" alt="buffer原理"></p>
<h3><span id="mark">mark</span></h3><p>初始值为-1，用于备份当前的position  </p>
<h3><span id="capacity">capacity</span></h3><p>capacity代表缓冲池的大小，当缓冲池满了，需要将其清空（通过读数据或者清除数据）才能继续往里写数据。</p>
<h3><span id="position">position</span></h3><p>position表示当前读/写的位置。<br>写模式中，position初始为0，当往缓冲池写入一个byte、long等数据时，postion会移到下一个可写的位置。<br>从写模式切换到读模式时，position重置为0，每读取一个数据，position会向前移动到下一个可读的位置</p>
<h3><span id="limit">limit</span></h3><p>在写模式下，Buffer的limit表示你最多能往Buffer里写多少数据（等于capacity）。当切换Buffer到读模式时，limit表示你最多能读到多少数据。因此，当切换Buffer到读模式时，limit会被设置成写模式下的position值。即之前写入的所有数据。</p>
<h2><span id="方法">方法</span></h2><p>mark()：把当前的position赋值给mark<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">mark</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mark = position;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>reset()：把mark值还原给position<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = mark;</span><br><span class="line">    <span class="keyword">if</span> (m &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InvalidMarkException();</span><br><span class="line">    position = m;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>clear()：一旦读完Buffer中的数据，需要让Buffer准备好再次被写入，clear会恢复状态值，但不会擦除数据。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    position = <span class="number">0</span>;</span><br><span class="line">    limit = capacity;</span><br><span class="line">    mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>flip()：Buffer有两种模式，写模式和读模式，flip后Buffer从写模式变成读模式。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">flip</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    limit = position;</span><br><span class="line">    position = <span class="number">0</span>;</span><br><span class="line">    mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>rewind()：重置position为0，从头读写数据。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">rewind</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    position = <span class="number">0</span>;</span><br><span class="line">    mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2><span id="分散聚集-scattergather">分散/聚集 Scatter/Gather</span></h2><p>Scatter（分散）：将一个channel的数据分散到多个缓存池中；<br>Gather：将多个缓冲池中的数据写入一个channel。<br>前者在将数据写入到下一个缓冲池前必须先将第一个池子填满，，而后者只能将position和limit之间的数据写入channel。因此前者不适合将大小不固定的消息读入多个缓冲池中，如消息体和消息消息头。后者适合写入灵活大小的消息，如把数据分为两部分，分别存放在headerBuffer和bodyBuffer中。</p>
<h1><span id="selector">selector</span></h1><p>想象一个场景：一个酒店服务员，负责好几个房间，每个房间住房、退房，她都会登记，这样当我们想知道某个房间的入住情况时，直接问这个服务员就好；<br>在selector模型中，每个channel相当于一个房间，selector相当于上述的服务员，线程可以通过一个selector监听多个channel的状态，在每个channel有相关事件就绪时，返回函数。需要知道的是</p>
<ol>
<li>selector是非阻塞的，所以阻塞channel（FileChannel）无法与他搭配使用。</li>
<li>需要让selector管理的channel必须先注册<br>   channel.register(selector,interstOps);<br>第二个参数代表selector对channel的什么事情感兴趣</li>
<li>要知道是否有channel事件就休可以调用select方法;返回值<br> 表示多少个channel事件就绪：<br> select()一直阻塞，直到事件就绪<br> select（long time），规定时间内channel没有事件就绪，直接返回0，<br>  seectNow()不会阻塞，不管什么通道就绪都立刻返回.</li>
<li><p>在select方法返回数据后，可以通过 selectedKeys()查看事件详情，SelectionKey结构如下：</p>
<ul>
<li><p>SelectionKey中定义了四个常量来表示事件</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">OP_READ = <span class="number">1</span> &lt;&lt; <span class="number">0</span>;</span><br><span class="line">OP_WRITE = <span class="number">1</span> &lt;&lt; <span class="number">2</span>;</span><br><span class="line">OP_CONNECT = <span class="number">1</span> &lt;&lt; <span class="number">3</span>;</span><br><span class="line">OP_ACCEPT = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>感兴趣的事件的集（或运算计算得a|b|c）             </p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> SelectionKey <span class="title">interestOps</span><span class="params">(<span class="keyword">int</span> ops)</span></span>;<span class="comment">//</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>已就绪的事件，可能多个，这样我们就可以判断当前channel是否可读/写/连接等</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">readyOps</span><span class="params">()</span></span>;</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isReadable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (readyOps() &amp; OP_READ) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isWritable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (readyOps() &amp; OP_WRITE) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h1><span id="实例">实例</span></h1><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Selector selector = Selector.open();</span><br><span class="line">channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">SelectionKey key = channel.register(selector, SelectionKey.OP_READ);</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">  <span class="keyword">int</span> readyChannels = selector.select();</span><br><span class="line">  <span class="keyword">if</span>(readyChannels == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">  Set selectedKeys = selector.selectedKeys();</span><br><span class="line">  Iterator keyIterator = selectedKeys.iterator();</span><br><span class="line">  <span class="keyword">while</span>(keyIterator.hasNext()) &#123;</span><br><span class="line">    SelectionKey key = keyIterator.next();</span><br><span class="line">    <span class="keyword">if</span>(key.isAcceptable()) &#123;</span><br><span class="line">        <span class="comment">// a connection was accepted by a ServerSocketChannel.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isConnectable()) &#123;</span><br><span class="line">        <span class="comment">// a connection was established with a remote server.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">        <span class="comment">// a channel is ready for reading</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isWritable()) &#123;</span><br><span class="line">        <span class="comment">// a channel is ready for writing</span></span><br><span class="line">    &#125;</span><br><span class="line">    keyIterator.remove();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><h1><span id="nio-优缺点">NIO 优缺点</span></h1><ul>
<li>单线程可以处理多任务，多线程可以处理更多的连接，节省了线程开支</li>
<li>socket主要的读、写、注册和接收函数，在等待就绪阶段都是非阻塞的，只有在I/O操作时是同步阻塞的（消耗CPU但性能非常高）</li>
<li>基于block的传输，通常比基于流的传输更高效</li>
<li><p>IO多路复用大大提高了Java网络应用的可伸缩性和实用性</p>
</li>
<li><p>并发程度不高或者局域网环境下NIO并没有显著的性能优势。</p>
</li>
<li>NIO没有完全屏蔽平台差异，各平台的实现存在差异。使用NIO做网络编程构建事件驱动模型并不容易。</li>
</ul>
<p>参考资料 <a href="http://tutorials.jenkov.com/java-nio/overview.html" target="_blank" rel="noopener">http://tutorials.jenkov.com/java-nio/overview.html</a></p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a class="article-share-link" data-url="http://www.boren33.com/2018/06/18/简聊JAVA-NIO/" data-id="cjl6yrgbd000cuiv2fl5ibkty" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACMElEQVR42u3aQW6EMAwF0Ln/panU1VQV8B0zVTGPFeqQwEsly4n9esXX9n29379f+TN7c/4e9frEhYGBcVvGdnj1GcdvqS7Z7lgMDIwHMPLpjkftjU3mPH7+5JsxMDAwGtTjD+2/FwMDAyNJ0TppZT4WAwMDI5nu+AVrQTlPHy/bi2NgYNyQsVYY+Jv7j9c3MDAw/j1jLdWrHvQn720loBgYGKMZa0leXpjMC5+dlBQDA2M2Ix9WbZVIQnC+MT5ZaAwMjNGMTskwSRnz47bk15NnMDAwhjKqH7G2Kc03vfk8P+4xMDAewMgTvqvKkNVWsJO3Y2BgjGZUg91VR/yd5Sg3h2FgYAxirDU9JIB+j0R5u4uBgTGOUT3i7zdk5Id6hcIDBgbGUEYeHJOp8zCazFNo+8DAwBjNyIuRnSOwtXSzWjrFwMCYyui3QVRbK/K/5MUGDAyM2YxOyTDfvuaHdNUlK+SVGBgYt2XkG85+obF/SLf7D8DAwBjNyJO5zi55rcBQLiFgYGAMZXQG50G5U3iIZsDAwHgAI99e5gE0SfKOn1w8NcTAwBjH6DRj5dvatdnKozAwMIYytuJVDYJrSWF5sTAwMEYzqlPnhYFqGK3OjIGB8TTGWgkzb6rotHcU1h4DA+MBjLUywLWATmjGwMDAyFsrrlqCfCuLgYGBUU3m8nn6JYHLAi4GBsZNGMkmNg+7eWvFWmlzN+BiYGAMZVxVGFhbiOQtUcDFwMCYyfgCKpR/rWZtp3cAAAAASUVORK5CYII=">分享</a><div class="tags"><a href="/tags/IO/">IO</a><a href="/tags/NIO/">NIO</a></div><div class="post-nav"><a class="pre" href="/2018/07/01/新梦想/">新梦想</a><a class="next" href="/2018/05/10/给过去的一封信/">给过去的一封信</a></div><div id="lv-container" data-id="city" data-uid="MTAyMC8zNTcwNy8xMjI0Mw=="><script>(function(d, s) {
   var j, e = d.getElementsByTagName(s)[0];
   if (typeof LivereTower === 'function') { return; }
   j = d.createElement(s);
   j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
   j.async = true;
   e.parentNode.insertBefore(j, e);
})(document, 'script');
</script></div></div></div></div><div class="pure-u-1 pure-u-md-1-4"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/往事随风/">往事随风</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术人生/">技术人生</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/随笔/" style="font-size: 15px;">随笔</a> <a href="/tags/hadoop/" style="font-size: 15px;">hadoop</a> <a href="/tags/algorithm/" style="font-size: 15px;">algorithm</a> <a href="/tags/IO/" style="font-size: 15px;">IO</a> <a href="/tags/NIO/" style="font-size: 15px;">NIO</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/08/24/HDFS高可用性介绍/">HDFS高可用性介绍</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/22/NameNode主备切换/">NameNode主备切换</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/01/新梦想/">新梦想</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/18/简聊JAVA-NIO/">简聊JAVA NIO</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/10/给过去的一封信/">给过去的一封信</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/23/遇见美丽/">遇见美丽</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/19/向左乐观,向右悲观/">向左乐观,向右悲观</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/06/排序算法总结/">排序算法总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/06/人生传/">人生传</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://tech.meituan.com" title="美团点评技术团队博客" target="_blank">美团点评技术团队博客</a><ul></ul><a href="http://jm.taobao.org" title="阿里中间件团队博客" target="_blank">阿里中间件团队博客</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">boren's blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.2.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.2.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>