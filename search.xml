<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>新梦想</title>
      <link href="/2018/07/01/%E6%96%B0%E6%A2%A6%E6%83%B3/"/>
      <url>/2018/07/01/%E6%96%B0%E6%A2%A6%E6%83%B3/</url>
      <content type="html"><![CDATA[<p>2018刚好过半，敬往事一杯酒，致新梦想以微笑。</p><p>新时代，新梦想，愿你在未来的每一天，不因过去而悔恨，只因今天而骄傲，加油。</p>]]></content>
      
      <categories>
          
          <category> 往事随风 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>简聊JAVA NIO</title>
      <link href="/2018/06/18/%E7%AE%80%E8%81%8AJAVA-NIO/"/>
      <url>/2018/06/18/%E7%AE%80%E8%81%8AJAVA-NIO/</url>
      <content type="html"><![CDATA[<p>   java NIO（non blocking IO），是一种同步非阻塞IO，为IO多路复用的基础，适用于高并发与大量连接，主要由三大组件构成：channel、Buffer、Selector，虽然还有一些其他组件，如管道，但大多是基于这三大组件而构造的。</p><h1 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h1><p>  与java BIO 数据流单向传输不同的是，NIO中引入了channel，它可以双向传输，既可以将数据通过缓冲写入到channel中，也可以将channel中的数据读入缓存。常见的channel类型有</p><p>  FileChannel（阻塞，无法结合selector使用）<br>  DatagramChannel<br>  SocketChannel<br>  ServerSocketChannel</p><h1 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h1><p>   缓冲Buffer容易理解，就是把读取到的数据放入一个或多个池中，等池子满了，可以一次拿走；或者将数据分别放到不同的池中，一次性传输到channel中。而不必多次运输。<br>   Buffer中有四个属性：mark、capacity、position、limit。</p><p>  <img src="/2018/06/18/简聊JAVA-NIO/images/buffer.png" alt="buffer原理"></p><h3 id="mark"><a href="#mark" class="headerlink" title="mark"></a>mark</h3><p>初始值为-1，用于备份当前的position  </p><h3 id="capacity"><a href="#capacity" class="headerlink" title="capacity"></a>capacity</h3><p>capacity代表缓冲池的大小，当缓冲池满了，需要将其清空（通过读数据或者清除数据）才能继续往里写数据。</p><h3 id="position"><a href="#position" class="headerlink" title="position"></a>position</h3><p>position表示当前读/写的位置。<br>写模式中，position初始为0，当往缓冲池写入一个byte、long等数据时，postion会移到下一个可写的位置。<br>从写模式切换到读模式时，position重置为0，每读取一个数据，position会向前移动到下一个可读的位置</p><h3 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h3><p>在写模式下，Buffer的limit表示你最多能往Buffer里写多少数据（等于capacity）。当切换Buffer到读模式时，limit表示你最多能读到多少数据。因此，当切换Buffer到读模式时，limit会被设置成写模式下的position值。即之前写入的所有数据。</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>mark()：把当前的position赋值给mark<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">mark</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mark = position;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>reset()：把mark值还原给position<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = mark;</span><br><span class="line">    <span class="keyword">if</span> (m &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InvalidMarkException();</span><br><span class="line">    position = m;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>clear()：一旦读完Buffer中的数据，需要让Buffer准备好再次被写入，clear会恢复状态值，但不会擦除数据。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    position = <span class="number">0</span>;</span><br><span class="line">    limit = capacity;</span><br><span class="line">    mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>flip()：Buffer有两种模式，写模式和读模式，flip后Buffer从写模式变成读模式。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">flip</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    limit = position;</span><br><span class="line">    position = <span class="number">0</span>;</span><br><span class="line">    mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>rewind()：重置position为0，从头读写数据。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">rewind</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    position = <span class="number">0</span>;</span><br><span class="line">    mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="分散-聚集-Scatter-Gather"><a href="#分散-聚集-Scatter-Gather" class="headerlink" title="分散/聚集 Scatter/Gather"></a>分散/聚集 Scatter/Gather</h2><p>Scatter（分散）：将一个channel的数据分散到多个缓存池中；<br>Gather：将多个缓冲池中的数据写入一个channel。<br>前者在将数据写入到下一个缓冲池前必须先将第一个池子填满，，而后者只能将position和limit之间的数据写入channel。因此前者不适合将大小不固定的消息读入多个缓冲池中，如消息体和消息消息头。后者适合写入灵活大小的消息，如把数据分为两部分，分别存放在headerBuffer和bodyBuffer中。</p><h1 id="selector"><a href="#selector" class="headerlink" title="selector"></a>selector</h1><p>想象一个场景：一个酒店服务员，负责好几个房间，每个房间住房、退房，她都会登记，这样当我们想知道某个房间的入住情况时，直接问这个服务员就好；<br>在selector模型中，每个channel相当于一个房间，selector相当于上述的服务员，线程可以通过一个selector监听多个channel的状态，在每个channel有相关事件就绪时，返回函数。需要知道的是</p><ol><li>selector是非阻塞的，所以阻塞channel（FileChannel）无法与他搭配使用。</li><li>需要让selector管理的channel必须先注册<br>   channel.register(selector,interstOps);<br>第二个参数代表selector对channel的什么事情感兴趣</li><li>要知道是否有channel事件就休可以调用select方法;返回值<br> 表示多少个channel事件就绪：<br> select()一直阻塞，直到事件就绪<br> select（long time），规定时间内channel没有事件就绪，直接返回0，<br>  seectNow()不会阻塞，不管什么通道就绪都立刻返回.</li><li><p>在select方法返回数据后，可以通过 selectedKeys()查看事件详情，SelectionKey结构如下：</p><ul><li><p>SelectionKey中定义了四个常量来表示事件</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">OP_READ = <span class="number">1</span> &lt;&lt; <span class="number">0</span>;</span><br><span class="line">OP_WRITE = <span class="number">1</span> &lt;&lt; <span class="number">2</span>;</span><br><span class="line">OP_CONNECT = <span class="number">1</span> &lt;&lt; <span class="number">3</span>;</span><br><span class="line">OP_ACCEPT = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br></pre></td></tr></table></figure></li><li><p>感兴趣的事件的集（或运算计算得a|b|c）             </p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> SelectionKey <span class="title">interestOps</span><span class="params">(<span class="keyword">int</span> ops)</span></span>;<span class="comment">//</span></span><br></pre></td></tr></table></figure></li><li><p>已就绪的事件，可能多个，这样我们就可以判断当前channel是否可读/写/连接等</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">readyOps</span><span class="params">()</span></span>;</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isReadable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (readyOps() &amp; OP_READ) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isWritable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (readyOps() &amp; OP_WRITE) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Selector selector = Selector.open();</span><br><span class="line">channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">SelectionKey key = channel.register(selector, SelectionKey.OP_READ);</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">  <span class="keyword">int</span> readyChannels = selector.select();</span><br><span class="line">  <span class="keyword">if</span>(readyChannels == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">  Set selectedKeys = selector.selectedKeys();</span><br><span class="line">  Iterator keyIterator = selectedKeys.iterator();</span><br><span class="line">  <span class="keyword">while</span>(keyIterator.hasNext()) &#123;</span><br><span class="line">    SelectionKey key = keyIterator.next();</span><br><span class="line">    <span class="keyword">if</span>(key.isAcceptable()) &#123;</span><br><span class="line">        <span class="comment">// a connection was accepted by a ServerSocketChannel.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isConnectable()) &#123;</span><br><span class="line">        <span class="comment">// a connection was established with a remote server.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">        <span class="comment">// a channel is ready for reading</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isWritable()) &#123;</span><br><span class="line">        <span class="comment">// a channel is ready for writing</span></span><br><span class="line">    &#125;</span><br><span class="line">    keyIterator.remove();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><h1 id="NIO-优缺点"><a href="#NIO-优缺点" class="headerlink" title="NIO 优缺点"></a>NIO 优缺点</h1><ul><li>单线程可以处理多任务，多线程可以处理更多的连接，节省了线程开支</li><li>socket主要的读、写、注册和接收函数，在等待就绪阶段都是非阻塞的，只有在I/O操作时是同步阻塞的（消耗CPU但性能非常高）</li><li>基于block的传输，通常比基于流的传输更高效</li><li><p>IO多路复用大大提高了Java网络应用的可伸缩性和实用性</p></li><li><p>并发程度不高或者局域网环境下NIO并没有显著的性能优势。</p></li><li>NIO没有完全屏蔽平台差异，各平台的实现存在差异。使用NIO做网络编程构建事件驱动模型并不容易。</li></ul><p>参考资料 <a href="http://tutorials.jenkov.com/java-nio/overview.html" target="_blank" rel="noopener">http://tutorials.jenkov.com/java-nio/overview.html</a></p>]]></content>
      
      <categories>
          
          <category> 技术人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IO </tag>
            
            <tag> NIO </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>给过去的一封信</title>
      <link href="/2018/05/10/%E7%BB%99%E8%BF%87%E5%8E%BB%E7%9A%84%E4%B8%80%E5%B0%81%E4%BF%A1/"/>
      <url>/2018/05/10/%E7%BB%99%E8%BF%87%E5%8E%BB%E7%9A%84%E4%B8%80%E5%B0%81%E4%BF%A1/</url>
      <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>痛苦要么成就一个人,要么彻底摧毁他!</strong></p><h2 id="忧伤的过去"><a href="#忧伤的过去" class="headerlink" title="忧伤的过去"></a>忧伤的过去</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;世界上最痛苦的事从不是我无法做到,而是我本可以…人们容易陷入过往的悔恨中,理由太多了,比如儿时的不懂事,为现在未来埋下祸根,亦是回眸之间,错过最重要的人,或者是包括过去的不努力,这些往往是相辅相成,不可分割,共同组成你的心魔.</p><h2 id="为什么要放下过去"><a href="#为什么要放下过去" class="headerlink" title="为什么要放下过去?"></a>为什么要放下过去?</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;曾经我问世界:命运是什么?它告诉我:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个人的命运不只是指他的天赋和出身，还包括那些”早年的经历”。在思想不成熟的时期，我们有可能无意识地犯下大错，从此影响了一生！这些都是不可控的。它叫作命运！命运无需在意，就像童年犯错一样。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而当我们真正明白并接受自己的过去后，我们就长大了，剩下的人生就不存在命运之说，此时的生活是事在人为，我们只需大胆追求想要得一切!<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对,在你走出来之前,你那些看似愚蠢的错误确实是一种命,当你想明白后,过去的你随过往时光都烟消云散,既然当初的自己随着过往都死了,那又与你何干</p><h2 id="如何放下过去"><a href="#如何放下过去" class="headerlink" title="如何放下过去."></a>如何放下过去.</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>别想一下就改变</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>别想没用的</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>别让自己的惯性思维害了自己</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;人总是在痛苦中不断成长,期间可能是无限循环的,直到一个时刻,这个条件被打破.这几天回顾了下过去的生活,发现自己始终没有真正走出来,亦无法全心全意的工作,这也困扰了我太多,越是这样越是愤恨自己,zui’hou发现了这么一个规矩:</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>一直做(想)一件事非常容易,但想打破这个状态时会异常难,这叫惯性.</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么是不是无法改变呢?当然不是,当我们开始一件新事物时,脑海中会有各种杂念,但是如果你足够意志坚定,这种抵触思维会慢慢消退.第一次可能痛苦好几天,第二次痛苦一两天,第三天几个小时,再到最后每次持续几分钟甚至几秒.到了后期,你会发现你战胜了过去的自己.一切似乎不可思议.长此以往,你就变得不再是当初的自己</p>]]></content>
      
      <categories>
          
          <category> 往事随风 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>遇见美丽</title>
      <link href="/2018/04/23/%E9%81%87%E8%A7%81%E7%BE%8E%E4%B8%BD/"/>
      <url>/2018/04/23/%E9%81%87%E8%A7%81%E7%BE%8E%E4%B8%BD/</url>
      <content type="html"><![CDATA[<p>生活不止眼前的苟且,还有诗和远方的田野<br>你赤手空拳来到人世间,为找到那片海不顾一切<br>当我寻找光明的时候，不小心陷入黑暗<br>迷茫，痛苦，懊悔，绝望…<a id="more"></a><br>我在蓝色的天空，策马奔腾<br>懊悔，愤怒，嘶吼，战斗<br>终于找到生命的奥秘<br>我告诉自己何为理想，何为生活<br>我以为自己没有快乐,更不再有悲伤<br>我似乎失去感知所有的能力<br>直到,<br>清风徐来，我遇见你，<br>这颗沉默的心开始颤抖<br>因为过分美丽，所以无限挣扎<br>回眸瞬间，错过风雨！<br>我告诉自己<br>如果疼痛无法治愈，就用血色谱写光阴。<br>终何去何从，请听何为<a href="https://www.zhihu.com/question/265653002/answer/296655901" target="_blank" rel="noopener">命运</a></p>]]></content>
      
      <categories>
          
          <category> 往事随风 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>向左乐观,向右悲观</title>
      <link href="/2018/04/19/%E5%90%91%E5%B7%A6%E4%B9%90%E8%A7%82,%E5%90%91%E5%8F%B3%E6%82%B2%E8%A7%82/"/>
      <url>/2018/04/19/%E5%90%91%E5%B7%A6%E4%B9%90%E8%A7%82,%E5%90%91%E5%8F%B3%E6%82%B2%E8%A7%82/</url>
      <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;人生本就是马拉松,有的人历经挫折,依然潇洒,有些人从未经历,却彷徨不前.仔细观察,不过是心在作怪.而如果把一生比作函数,我们会发现一个有趣的现象:</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;掉入局部最大值的时候，人们知道这不是全局最大的，<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;掉入局部最小值时，人们总觉得这是全局最小值</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此想要快乐的活着,最关键的还是要<strong>突破思维</strong>,改变自己!</p>]]></content>
      
      <categories>
          
          <category> 往事随风 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>排序算法总结</title>
      <link href="/2018/04/06/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
      <url>/2018/04/06/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;排序,顾名思义,将数据按照某种规则排列起来.这种规则可以是根据基本的数值大小排序,也可以是通过字符串长度比较来排序,又或者是优先根据两个字符串的第一个不同值为参考来比较的排序(String的compareTo默认方法),而这个规则可以是各式各样的,你可以根据义务来自己定制排序策略,今天我们主要探讨数据结构与算法中8中基本的排序算法(全部根据数值大小比较)</p>]]></content>
      
      <categories>
          
          <category> 技术人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>人生传</title>
      <link href="/2018/04/06/%E4%BA%BA%E7%94%9F%E4%BC%A0/"/>
      <url>/2018/04/06/%E4%BA%BA%E7%94%9F%E4%BC%A0/</url>
      <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>  如果人生是一场炼狱,那我们何去何从<br>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;—&lt;&lt;魔也,道也&gt;&gt;</p><h2 id="出入尘世-天真无邪"><a href="#出入尘世-天真无邪" class="headerlink" title="出入尘世,天真无邪"></a>出入尘世,天真无邪</h2><p>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;童年的我特别乖,有一次奶奶的救心丸找不到了,斥责我是不是偷去玩了,自己死活不肯承认,后来看她越来越急,就说”别找了,本少爷玩丢了”,然后就是一顿毒打….过了几天,救心丸出现在了奶奶的药盒.<br>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;小时候,村里就一个老师,同时教幼儿园到小学3年级,作为当代最小屁孩,我跟着大屁孩们一起上课,当时自己总是喜欢研究一些数学”怪题”,结局也都不错,但是特别讨厌学语文,可惜不背课文不让吃饭,于是我就特别认真的背,记得当时把几本书从头到尾背完,接着反着背,因此拿到5块钱巨款作为零花钱.</p><h2 id="无关对错-只为快乐"><a href="#无关对错-只为快乐" class="headerlink" title="无关对错,只为快乐"></a>无关对错,只为快乐</h2><p>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;过去10-15年,大多数中国农村家庭十分贫穷,我家也不例外,曾经的梦想是拥有一台电脑,玩一辈子问道.还记得以前经常饿肚子,但是一玩游戏或者想象自己在玩游戏,就变得精神抖擞,这一直持续了七年,在很多人眼里这是荒废,不务正业,但它确实是一生中最纯净的时光,这就是信仰的力量吧.直到读了乔布斯传,身体的血液开始燃烧,觉得我应该改变自己,于是开始好好学习</p><h2 id="悔恨犹在-何去何从"><a href="#悔恨犹在-何去何从" class="headerlink" title="悔恨犹在,何去何从"></a>悔恨犹在,何去何从</h2><p>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我的高中很不快乐,经常一个人在操场散步,或者回到教室装睡,然后沉思,时间长了,变本加厉,总是处于对过去的不满和自身的懊悔中,我从不惧怕未来,却不能接受过去,越是走不出来,浪费越多时间,时间越长,自责更深,恶性循环,此时我已从当年反应敏捷的儿童变成略有迟钝的少年.这些事情让人如此痛苦,以至于我不得不”先解决心情,再解决事情”.我找了大量心理学书,结果根本没耐心看,全理论知识,仿佛是一本本教科书.废话连篇.直到后来慢慢明白痛苦是正常的,一个人承受越大的痛苦,未来可以抗住越大的打击.,相反一个没有过痛苦和思考的人,他的一生得多普通啊?</p><h2 id="如梦初醒-大步朝前"><a href="#如梦初醒-大步朝前" class="headerlink" title="如梦初醒,大步朝前"></a>如梦初醒,大步朝前</h2><p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;黑暗光明,黑暗光明,黑暗光明,惶惶中6年时间过去,已不再是当初的少年,这时更清楚自己想成为什么样的人,我开始朝着自己的梦想(兼具艺术和技术的优秀工程师)逐步努力.此时已是大二下学期.每天不去上课,沉迷于图书馆,看着妹子,刷着一道道算法题,每次accept,都触动着内心,看编译原理时,也总是惊呼原来如此,学习计网时,从一开始的认为理所当然到知其所以然都是一种兴奋,研读jdk源码时,从一开始的懵逼到初为了解,再到懵逼,再到了解..不得不感叹大佬的智慧.终于结果是美丽的,春招拿到一些互联网公司offer,最后去了小米科技(Mi fan),做push服务端开发</p><h2 id="面朝大海-春暖花开"><a href="#面朝大海-春暖花开" class="headerlink" title="面朝大海,春暖花开"></a>面朝大海,春暖花开</h2><p>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一花一世界，一叶一如来.这个世界无所谓缺陷，即使是缺陷，也是美的.让我们朝着梦想前进</p>]]></content>
      
      <categories>
          
          <category> 往事随风 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
