<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Zookeeper入门介绍</title>
      <link href="/Zookeeper%E5%85%A5%E9%97%A8%E4%BB%8B%E7%BB%8D.html"/>
      <url>/Zookeeper%E5%85%A5%E9%97%A8%E4%BB%8B%E7%BB%8D.html</url>
      <content type="html"><![CDATA[<p>zookeeper是一个分布式的、开源的协调服务，它实现了一系列基础服务，并暴露出简单的接口供分布式应用程序使用，依赖这些接口，分布式应用可以实现一些更高级的的服务，如同步、配置管理、集群管理、命名服务。在zookeeper的设计上，是易于编码的，在数据模型上，它类似于传统的文件系统。<br>众所知周，协调服务很难搞定，它很容易出现错误，比如资源竞争、死锁。zookeeper所追求的是让分布式系统不用再重新实现协调服务。<br><a id="more"></a></p><h2><span id="设计目标">设计目标</span></h2><p><strong>简单</strong>： zookeeper允许分布式进程通过一个共享的namespace来与协调彼此，namespace由data registers组成，在zookeeper中，这些registers称为znodes，znodes类似于文件和目录，不过和传统文件系统不一样的是，znodes存储在内存中，因此zookeeper具有高吞吐量和低延迟的特性。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;zookeeper的实现聚焦于高性能、高可用、严格的顺序访问，高性能意味着zookeeper可以用在大型分布式系统中，可靠性保证了它不会出现单点故障，严格的顺序访问使得客户端可以实现原子同步。</p><p><strong>可靠</strong>：就像它所协调的分布式进程一样，它本身就通过一些列主机来实现备份。组成zookeeper service的所有主机必须感知到彼此. 他们维护着一个表示状态的内存镜像、事务日志、以及持久化存储的快照。只要大多数的机器是可用的，那么整个zookeeper服务就是可用的。client servers会连接到zk server的一个机器上，客户端通过维护一个TCP 连接来 发送请求、获取响应、获取监控事件、发送心跳。如果连向服务器的连接break，客户端将会连接到另一台server。</p><p><img src="http://peknp8v13.bkt.clouddn.com/image/zookeeper/zkservice.jpg" alt="Zookeeper Service"></p><p><strong>有序</strong>：zookeeper会给每次更新都标识一个数字，从而反应zookeeper的操作序列，随后的操作可以使用这个序列去实现更高层的服务，如同步原语。<br><strong>快速</strong>： 当读操作占多数工作量的情况下，zookeeper表现的尤其快速，ZooKeeper应用程序运行在成千的机器上，当read操作更多，且read/write的比例为10：1时，它的性能最佳</p><h2><span id="zookeeper-数据模型">Zookeeper 数据模型</span></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;与传统文件系统不同的是，znode在包含数据的同时，也可以包含子节点。Zookeeper被设计来存储协调数据：状态信息、配置信息、位置信息等等，所以存在每个节点上的数据往往很小，为了简便，我们把ZooKeeper data nodes简称为znode。</p><p><img src="http://peknp8v13.bkt.clouddn.com/image/zookeeper/zknamespace.jpg" alt="Zookeeper namespace"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;znode维护着一个stats structure来允许缓存检验和协调更新，该结构包含了 数据变更的 版本号、ACL变更以及时间戳。每当一个znode的数据改变时，版本号就会增加，当客户端获取数据时，他也会返回数据的版本。当客户端更改数据时，需要提供对应znode的数据版本号，如果它和实际版本号不同，更改操作会拒绝执行。zookeeper还有临时节点的概念，随着会话的创建而激活，同时在会话结束时，被删除。</p><h3><span id="zookeeper中的时间"><strong>ZooKeeper中的时间</strong></span></h3><p>ZooKeeper以多种方式跟踪时间：</p><ul><li>Zxid：ZooKeeper状态的每次变化都接收一个<em>zxid（</em>ZooKeeper事务id）形式的标记。这个展示了所有的ZooKeeper的变更顺序。每次变更会有一个唯一的zxid，如果zxid1小于zxid2说明zxid1在zxid2之前发生。</li><li>Version numbers：节点的每次变化都会引起这个节点版本号之一的一次增加。这三个版本号是：version（一个节点的数据变化次数），cversion（一个节点的子节点变化次数），aversion（一个节点的ACL 变化次数）。</li><li>Tricks：当使用多个ZooKeeper服务，服务器使用ticks来确定事件的时间，比如说状态上传、会话超时、连接超时等。这个tick时间仅仅通过最小会话超时时间间接的暴露出来；如果一个客户端请求会话的超时时间小于最小超时时间，服务器将会告诉客户端实际的会话超时时间是最小超时时间。</li><li>Real Time：ZooKeeper不使用实时、时钟时间。除了把时间戳放在stat结构中。</li></ul><h3><span id="zookeeper-stat-结构"><strong>ZooKeeper Stat 结构</strong></span></h3><p>每个节点的Stat结构由下列字段组成：</p><ul><li>czxid：该数据节点被创建时的事务id。</li><li>mzxid：该节点最后一次被更新时的事务id。</li><li>ctime：节点被创建时的时间。</li><li>mtime：节点最后一次被更新时的时间。</li><li>version：这个节点的数据变化的次数。</li><li>cversion：这个节点的子节点 变化次数。</li><li>aversion：这个节点的ACL变化次数。</li><li>ephemeralOwner：如果这个节点是临时节点，表示创建者的会话id。如果不是临时节点，这个值是0。</li><li>dataLength：这个节点的数据长度。</li><li>numChildren：这个节点的子节点个数。</li></ul><h2><span id="zookeeper-会话">Zookeeper 会话</span></h2><p>客户端通过binding API创建一个到service的处理器，从而创建会话，一旦创建了，处理器会启动，会话处于connecting状态，然后客户端会尝试与server建立连接，建立连接后，变为connected状态。此时如果一个错误发生（如会话过期、认证失败）或者是应用程序要求关闭处理器，则会转为close状态。下图展示了zookeeper可能出现的状态转换。</p><p><img src="http://peknp8v13.bkt.clouddn.com/image/zookeeper/zk_state.png" alt="Zookeeper状态转换图"></p><h2><span id="zookeeper-监听通知机制">Zookeeper 监听（通知机制）</span></h2><p>zookeeper支持监听的概念，客户端可以在一个znode上设置监听，当znode改变时，监听将会被触发或者移除。当监听被触发时，客户端会收到一个提示数据发生变更的包，当客户端和某个zk server的连接中断时，客户端将会收到一个本地通知。</p><p><strong>注意事项</strong></p><ul><li>监听是一次性的，如果你等到了一个监听事件，并且在该事件在未来改变时，继续获取通知，那你得再次注册监听</li><li>因为监听是一次性的，并且在获取锁到发送请求再次获取锁的这段时间存在延迟，所以你无法保证看到每一次的事件改变。准备好处理这种情况—在两次获取事件的时间段内，znode改变了多次，虽然你可能不鸟这个事，但起码要知道它可能发生。</li></ul><h2><span id="zookeeper-访问控制acl">Zookeeper 访问控制ACL</span></h2><p>ZooKeeper使用ACLs来控制znodes的权限，ACL实现与UNIX 文件访问权限类似，采用字节位来表示操作权限，与UNIX 文件访问权限不同的是，ZooKeeper没有域的概念（user、group、world），即znode没有owner的概念。不过ACL包含了一组ids和这些id所拥有的权限。需要注意的是ACLS不具有传递性（递归性），比如host1能访问<em>/app不代表其能访问</em>/app/partition1。zookeeper定义了如下权限：</p><ol><li>create : 创建<strong>子节点</strong>的权限</li><li>delete：删除<strong>子节点</strong>的权限</li><li>read： 读取<strong>节点数据和子节点列表</strong>的权限</li><li>write：更新<strong>节点数据</strong>的权限</li><li>admin：设置<strong>节点ACL</strong>的权限</li></ol><h2><span id="zookeeper-保证">Zookeeper 保证</span></h2><p>zookeeper足够的简单、快速，也正是这个原因，使它成为构造更复杂服务的基础，比如同步服务。它提供了以下保证：</p><ul><li>顺序一致性: 客户端更新操作的顺序将会按照请求顺序执行</li><li>原子性操作：更新操作要么成功，要么失败，没有中间状态</li><li>统一的系统镜像： 无论客户端连接的哪台机器，看到的系统镜像都一样</li><li>可靠性： 一旦更新操作被执行，将会永远被持久化，直到下一次更新</li><li>时效性：在客户端视角，一个时间段内，系统镜像是最新的，在这个时间段的任何变动都会被客户端发现。</li></ul><h2><span id="zookeeper-读写操作">Zookeeper 读写操作</span></h2><p>下图展示了zookeeper服务中比较上层的组件，除了请求处理器的异常情况之外.  组成zookeeper服务的每一台zookeeper server都保存着它每个组件的副本.</p><p><img src="http://peknp8v13.bkt.clouddn.com/image/zookeeper/zkcomponents.jpg" alt="zkcomponents"></p><p>备份数据库是一个内存数据库，保存了个整个结构树的数据，更新操作会被保存到磁盘，用于异常修复。在写操作被应用到内存数据库前，zk会先把写操作序列化到磁盘。在zookeeper中，server为多个客户端提供服务，客户端会连接到一个server来提交请求，读请求会直接读本地的备份数据库，而改变服务状态的请求、写请求则是通过一致性协议来处理。</p><p>一致性协议规定：所有的写操作都会被转发到leader，followers则接受来自leader的消息建议并统一消息传输。消息传输层只关注leader故障-替换和同步数据。</p><p>zookeepr使用了自定义的原子协议。由于消息层是原子性的，Zookeeper可以保证本地server的本地副本不会数据错乱。当leader server收到写请求后，它会计算写入数据后的系统状态，并把获取到新状态转化为事务</p><h2><span id="zookeeper-能提供什么">Zookeeper 能提供什么</span></h2><h4><span id="命名服务name-service">命名服务Name Service</span></h4><p>在zookeeper中创建一个节点，即有唯一的path。在我们无法确定上游程序的部署机器时即可与下游程序约定好path。</p><h4><span id="配置管理">配置管理</span></h4><p>程序总是需要配置的，如果程序分散部署在多台机器上，要逐个改变配置就变得困难。现在把这些配置全部放到zookeeper上去，保存在 Zookeeper 的某个目录节点中，然后所有相关应用程序对这个目录节点进行监听，一旦配置信息发生变化，每个应用程序就会收到 Zookeeper 的通知，然后从 Zookeeper 获取新的配置信息应用到系统中就好</p><h4><span id="集群管理group-membership">集群管理Group Membership</span></h4><p>所谓集群管理无在乎两点：1是否有机器退出和加入 ，2 选举master。  对于第一点，所有机器约定在父目录GroupMembers下创建临时目录节点，然后监听父目录节点的子节点变化消息。一旦有机器挂掉，该机器与 zookeeper的连接断开，其所创建的临时目录节点被删除，所有其他机器都收到通知：某个兄弟目录被删除，于是，所有人都知道：它上船了。 新机器加入也是类似，所有机器收到通知：新兄弟目录加入，highcount又有了，对于第二点，我们稍微改变一下，所有机器创建临时顺序编号目录节点，每次选取编号最小的机器作为master就好。</p><h4><span id="分布式锁">分布式锁</span></h4><p>有了zookeeper的一致性文件系统，锁的问题变得容易。锁服务可以分为两类，一个是保持独占，另一个是控制时序。  对于第一类，我们将zookeeper上的一个znode看作是一把锁，通过createznode的方式来实现。所有客户端都去创建 /distribute_lock 节点，最终成功创建的那个客户端也即拥有了这把锁。用完删除掉自己创建的distribute_lock 节点就释放出锁。  对于第二类， /distribute_lock 已经预先存在，所有客户端在它下面创建临时顺序编号目录节点，和选master一样，编号最小的获得锁，用完删除，依次方便。</p><h2><span id="zookeeper应用场景">Zookeeper应用场景</span></h2><ul><li>Apache Hadoop 依靠 ZooKeeper 来实现 Hadoop HDFS NameNode 的自动故障转移，以及 YARN ResourceManager 的高可用性。</li><li>Apache HBase 是构建于 Hadoop 之上的分布式数据库，它使用 ZooKeeper 来实现区域服务器的主选举（master election）、租赁管理以及区域服务器之间的其他通信。</li></ul><h2><span id="使用zookeeper的注意事项">使用Zookeeper的注意事项</span></h2><p>ZooKeeper是简单的、快速的，你的应用程序也在工作，但是注意，这仍然有一些陷阱：</p><ol><li>当你使用监听的时候，你必须关注对建立连接感兴趣的监听事件。当zk客户端与服务端断了连接时，你接收不到任何通知，直到你重新连接。当你关注一个节点是否存在时，在node创建或删除时正好连接断了，你将丢失这个事件。</li><li>你必须测试zookeeper故障。当大多数zookeeper存活时，zk service就不会挂掉，但是你能否处理它？在现实中，zk连接可能会断掉（通常是因为网络分区或者server宕机），此时，zk客户端会与其他server重连，并告诉你发生了什么，但是你得确保你可以恢复记忆并且基础处理未执行完的请求。所以你应该在测试环境测试下能否正常恢复。</li><li>注意事务日志的存放位置。最影响zookeeper性能的就数事务日志了，在回复客户端前ZooKeeper必须把事务日志先同步到硬盘中，因此专门设置一些专门的机器来存放事务日志是有助于提高性能的。相反地.把事务日志存放在一个繁忙的机器上，将会影响到性能. </li><li>正确地设置java max heap size，不必要的磁盘交互会影响性能。你需要记住，<strong>在zookeeper中一切都是有序的</strong>，如果一个请求需要和磁盘，其他排队的请求也会和磁盘交互。为了避免和磁盘交互，可以把heapsize设置为机器的空余空间（物理内存 - OS所需内存 - cache）</li></ol><p>参考资料：</p><ol><li><a href="https://zookeeper.apache.org/doc/current/zookeeperOver.html" target="_blank" rel="noopener">https://zookeeper.apache.org/doc/current/zookeeperOver.html</a></li><li><a href="https://zookeeper.apache.org/doc/current/zookeeperProgrammers.html" target="_blank" rel="noopener">https://zookeeper.apache.org/doc/current/zookeeperProgrammers.html</a></li></ol>]]></content>
      
      <categories>
          
          <category> 技术人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Zookeeper </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Kafka介绍</title>
      <link href="/Kafka%E4%BB%8B%E7%BB%8D.html"/>
      <url>/Kafka%E4%BB%8B%E7%BB%8D.html</url>
      <content type="html"><![CDATA[<h3><span id="描述一">描述一</span></h3><p>Kafka是一个分布式的流处理平台。一个流处理平台通常有以下特征</p><ol><li>发布和订阅消息流（类似于消息队列或者企业级的消息系统）</li><li>以容错的、持久的方式存储消息流</li><li>当消息流到来的时候，处理消息<a id="more"></a></li></ol><h3><span id="描述二">描述二</span></h3><p>Kafka是一个分布式、分区的、多副本的、多订阅者，基于zookeeper协调的分布式日志系统，其主要特点为：</p><ol><li>以时间复杂度为O(1)的方式提供消息持久化能力，即使对TB级以上数据也能保证常数时间的访问性能</li><li>高吞吐率。即使在非常廉价的商用机器上也能做到单机支持每秒100K条消息的传输</li><li>支持Kafka Server间的消息分区，及分布式消费，同时保证每个partition内的消息顺序传输</li><li>同时支持离线数据处理和实时数据处理</li></ol><h2><span id="应用场景">应用场景</span></h2><ol><li>数据推送</li><li>作为大缓冲区使用</li><li>日志收集（scribe或者nginx）</li><li>服务中间件</li></ol><h2><span id="kafka架构">Kafka架构</span></h2><p><img src="http://peknp8v13.bkt.clouddn.com/image/kafkaimage-20180904002950252.jpg" alt="kafka架构"></p><h3><span id="topic">Topic</span></h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;消息的类别。Kafka中可以将Topic从物理上划分成一个或多个分区（Partition），每个分区在物理上对应一个文件夹，以”topicName_partitionIndex”的命名方式命名，该dir包含了这个分区的所有消息(.log)和索引文件(.index)，这使得Kafka的吞吐率可以水平扩展。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;producer在发布消息的时候，可以为每条消息指定Key，这样消息被发送到broker时，会根据分区算法把消息存储到对应的分区中（一个分区存储多个消息），如果分区规则设置的合理，那么所有的消息将会被均匀的分布到不同的分区中，这样就实现了负载均衡。</p><h3><span id="broker">Broker</span></h3><p>代理，用来存储消息，Kafka集群中的每一个服务器都是一个代理（Broker），消费者将从broker拉取订阅的消息</p><h3><span id="producer">Producer</span></h3><p>向Kafa发送消息的进程，生产者会根据topic分布消息。生产者也负责把消息关联到Topic上的哪一个分区。最简单的方式从分区列表中轮流选择。也可以根据某种算法依照权重选择分区。算法由开发者定义。</p><h3><span id="cousumer">Cousumer</span></h3><p>Consermer实例可以是独立的进程，负责订阅和消费消息。消费者用consumerGroup来标识自己。同一个消费组可以并发地消费多个分区的消息，同一个partition也可以由多个consumerGroup并发消费，但是在consumerGroup中一个partition只能由一个consumer消费</p><h3><span id="cousumergroup">CousumerGroup</span></h3><p>Consumer Group：同一个Consumer Group中的Consumers，Kafka将相应Topic中的每个消息只发送给其中一个Consumer</p><h2><span id="kafka详解">Kafka详解</span></h2><h3><span id="主题和分区topics-and-partitions">主题和分区（Topics and partitions）</span></h3><p>对于每个topic，Kafka都用分区的的方法维护（如下图）</p><p><img src="https://kafka.apache.org/20/images/log_anatomy.png" alt="screenshot"></p><h4><span id="partition">Partition</span></h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对Topic中的消息做水平切分，每块称为一个Partition。每个分区都是一个 顺序的、不可变的消息队列， 并且可以持续的添加;分区中的消息都被分了一个序列号，称之为偏移量(offset)，在每个分区中此偏移量都是唯一的。</p><h4><span id="消费序列">消费序列</span></h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;无论消息是否被消费了，Kafka集群都会保存所有的消息，直到它们过期 。比如我们配置一个消息的有效期为两天，那么消息发布的两天内，consumer可以消费消息，而超出时间后，消息将被丢弃以释放空间。那么Kafa怎么知道消费到哪儿了呢？每个消费者都维护着一个元数据（偏移量，消费者的消费进度)。这个offset由消费者控制：当consumer消费消息的时候，偏移量也线性地增加。但是偏移量由消费者控制，所以消费者能够把偏移量重置为一个更老的，以便重新读取。此外，由于偏移量由消费者控制offset， 一个消费者的操作不会影响其它消费者对此log的处理。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这些特点使得Kafka消费者的成本很低，他们可以来取自如的消费消息，而且不影响其他消费者，这样，我们可以用tail命令处理任何topic，而不需要改变这些消息。再说说分区。Kafka中采用分区的设计有以下好处。一是可以水平扩展，不受单台服务器的限制；Topic拥有多个分区意味着它可以不受限的处理更多的数据。第二，分区可以作为并行处理的单元，稍后会谈到这一点。</p><h3><span id="分布式">分布式</span></h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log的分区被分散的存储在Kafka集群中，每个服务器只处理分配到它机器上的partitions。此外，partation会根据配置备份到其他server以实现容错性。每个分区，只有一个server可以作为partation Leader，其他的都将作为follower。leader负责处理partation的读写请求，followers被动的同步数据，以便在leader挂掉的时候，升级为leader。需要知道的是，每个server都是一些分区的leader，同事又是其他分区的flowwer，以更好地实现负载均衡，避免热点问题。</p><h3><span id="异地同步">异地同步</span></h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Kafka MirrorMaker为群集提供<code>geo-replication</code>支持。借助<code>MirrorMaker</code>，消息可以跨多个数据中心或云区域进行复制、同步。 我们可以利用它在active/passive场景中备份和恢复; 或者在active/passive方案中将数据置于更接近用户的位置，或数据本地化。  </p><h3><span id="保证">保证</span></h3><ol><li>消息将会以被sent的顺序添加到partition Log中</li><li>消费者将先看到先加入到partition Log中的消息</li><li>对于一个topic的消息，如果备份数为N，系统最多容许有N-1台失败，而不丢失commit到log的消息</li></ol><h3><span id="kafka作为一个消息系统">Kafka作为一个消息系统</span></h3><p>与传统的企业级消息系统相比，Kafka如何？</p><p>传统的消息系统有两种模型：</p><ul><li>队列模型：一组消费者去消费server上的消息，但是一个消息只能被一个consumer消费</li><li>发布-订阅模型： 每个消息都会广播到每个消费者，即每个消费者都会消费</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;队列模型让多个consumer瓜分消息并消费，这样可以很好地水平扩展，提高性能，但和队列模型不同的是，消息一旦被读取就会被干掉，因此有丢数据的风险；发布订阅模型会把每个消息都广播给订阅者，因为不方便做水平扩展。</p><ol><li><strong>Kafka同时具备队列模型和发布-订阅模型，你不必纠结于消息系统模型的二选一</strong></li></ol><p>&nbsp;&nbsp;&nbsp;&nbsp;Kafka的 consumerGroup结合上这两中模型：队列模型-同一group中，一个messgae只有一个consumer消费，消息多的时候，往group中添加consumer就好，容易扩展；发布订阅模型：同一个消息可以被广播到不同的consumerGroup中。</p><ol start="2"><li><strong>kafka有更强的顺序保证机制</strong></li></ol><p>&nbsp;&nbsp;&nbsp;&nbsp;传统的消息队列按序保存消息，如果有多个消费者从队列消费消息，server将会按照顺序把消息移出队列，不幸的是，即使server顺序移出消息，但是消息到达consumers的过程是异步的，所以他们真正抵达消费者的顺序与stored进队列时不同，消息系统的解决方案是只让一个consumer去消费这个队列，然而这又违背了并发。</p><p>这方面，Kafka做的更好，通过分区概念，在一个topic下，Kafka能同时满足</p><ul><li>顺序保证：同一个partition的消息只能由group中的一个consumer消费</li><li>负载均衡：由于有多个partition，所以仍然具有并发性</li></ul><p><strong>需要注意的是，group中的consumer数不能大于partition，否则会造成空闲</strong></p><h3><span id="kafka作为一个存储系统">Kafka作为一个存储系统</span></h3><p>任何允许把发布消息和消费消息过程解耦的消息队列，本质上都充当了存储系统，不同的是，Kafka是一个高性能的存储系统：</p><ul><li>写到kafka的数据会被写到硬盘，并且备份，以实现容错。Kafka允许生产者等待消息应答，直到完成备份，保证持久化了。</li><li>Kafka的硬盘结构可以水平扩展，无论你的server是50K还是50T，都可以很好的执行</li></ul><p>由于重视存储并且允许client去控制读取位置，你还可以认为kafka是一种具备高性能，低延迟，提交日志存储，复制，和传播特性的分布式文件系统</p><h3><span id="kafka流处理">Kafka流处理</span></h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不只是读写和存储数据，Kafka的目标是能够实时流处理。在kafka中，流处理持续获取<code>输入topic</code>的数据，进行处理加工，然后写入<code>输出topic</code>。例如，一个零售APP，接收销售和出货的<code>输入流</code>，统计数量或调整价格后输出。</p><h3><span id="批处理">批处理</span></h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;把消息、存储、流处理组合在一起似乎并不常见，但对于Kafka来说是非常有必要的，因为它的目标是做一个流平台。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;类似于HDFS的分布式文件系统允许存储静态文件来进行批处理。这种系统能够有效地存储和处理历史数据; 传统的消息系统允许你处理订阅topic之后才到达的topic消息。Kafka结合了这两种能力，这种组合对于kafka作为流处理应用的平台和流数据管道的平台是至关重要的。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;作为流式应用程序，Kafka通过组合存储和低延迟订阅，可用相同的方式处理过去和未来的数据。 这意味着一个单一的应用程序可以处理历史记录的数据，并且在到达最后一条记录时不用结束，而是等待future data。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;作为流数据管道，Kafka能够订阅实时事件，因此Kafka可作为低延迟的管道; 同时Kafka可靠存储数据的特性使得它能够存储一些要求较高的数据(保证安全送达or系统因维护下线一段时间也不会丢数据）。</p><p>本文主要翻译自：<a href="https://kafka.apache.org/intro" target="_blank" rel="noopener">https://kafka.apache.org/intro</a></p>]]></content>
      
      <categories>
          
          <category> 技术人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kafka </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>HDFS高可用性介绍</title>
      <link href="/HDFS%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7%E4%BB%8B%E7%BB%8D.html"/>
      <url>/HDFS%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7%E4%BB%8B%E7%BB%8D.html</url>
      <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在hadoop2.0.0之前，HDFS集群中存在NameNode单点故障的问题，只要集群中一个NameNode不可用时，整个cluster将不可用，直到nameNode被重启或者或者备份到了另一个独立的机器.造成问题的原因可能是：</p><ol><li>NameNode所在机器突然宕机，集群将陷入瘫痪，直到NameNode服务重启</li><li>NameNode所在机器软硬件升级，将会导致集群在期间无法提供服务</li></ol><p>&nbsp;&nbsp;&nbsp;&nbsp; HDFS HA的实现方式是在每个HDFS集群中运行两个NameNode（or more），他们以主/从模式运行，activeNode负责接收客户端的读写操作，将操作保存在JNS集群中，从节点会不断地读取JNS集群中的操作信息，从而实现主从NameNode数据同步，当主Node节点不可用时，把从节点切换为主节点。</p><h3><span id="ha-架构设计">HA 架构设计</span></h3><p>&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;在典型的HA架构中，two or more独立的机器被配置为Namenode，任何时刻，只有一个Namenode处于Active状态，其他都处于standby状态；Active Namenode负责接收Client端请求，Standy节点作为备胎并没资格和客户端交互，它只是不停地备份数据，努力与ActiveNode保持一致，争取在主机点挂掉后切换为主节点。</p><p>&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;为了让Standby Node与Active Node保持同步，这两个Node都与一组称为JNS的独立的进程通信(Journal Nodes)。当Active Node接受客户端请求修改了namespace，它将把修改log写入到到JNS集群的大多数节点。Standby noes会不断地监控JNS集群上edit log的改变。当Standby Node看到写入完成的edit log后，会将log同步到自己的namespace中。这样在主从节点切换时，Standby可以确保已经从从JNS中读取到了activeNode记录的所有edits。为了支持快速切换，Standby node必须持有集群中所有block的最新位置。为此，所有Datanode都配置了Namenodes的地址（主从都配置），并把block位置上报给它们。    </p><p>&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;任何时刻，集群中只能有一个Active Namenode为客户端提供服务，否则会造成数据丢失或者结果不一致，这是灾难性的。比如当oldActiveNode宕机后，有newActiveNode被提拔为主节点，当oldActiveNode醒悟时，可能因网络延时等原因认为自己任然是主节点并继续提供服务，这就造成了我们成为双主或脑裂（）的行为。HDFS的应对措施是：JNS永远只允许一个Namenode作为writer；在failover期间，只有被选中为未来主节点（唯一）的Standby Node可以代替oldActiveNode的职责，向JNS写入log，这就阻止了其他Namenode基于处于Active状态的问题。此外主从节点namespaces快速同步是必须的，否则主节点挂掉后会因为同步时间长而有很长的空窗期集群瘫痪。</p><h3><span id="高可用性实现">高可用性实现</span></h3><p>&nbsp;&nbsp;&nbsp;&nbsp; HDFS的HA实现主要包括两部分：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://www.boren33.com/NameNode主备切换.html">NameNode主从切换</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="">NameNode数据同步</a></p><p>&nbsp;&nbsp;&nbsp;&nbsp; 本文翻译自<a href="http://hadoop.apache.org/docs/r3.1.1/hadoop-project-dist/hadoop-hdfs/HDFSHighAvailabilityWithQJM.html" target="_blank" rel="noopener">http://hadoop.apache.org/docs/r3.1.1/hadoop-project-dist/hadoop-hdfs/HDFSHighAvailabilityWithQJM.html</a></p>]]></content>
      
      <categories>
          
          <category> 技术人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hadoop </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>NameNode主备切换</title>
      <link href="/NameNode%E4%B8%BB%E5%A4%87%E5%88%87%E6%8D%A2.html"/>
      <url>/NameNode%E4%B8%BB%E5%A4%87%E5%88%87%E6%8D%A2.html</url>
      <content type="html"><![CDATA[<p>​        主备切换控制器 (ZKFailoverController )作为独立的进程运行，与HealthMonitor 、ActiveStandbyElector两大组件一起对 NameNode 的主备切换进行控制。它启动时，会初始化ActiveStandyElector和healthMonitor,并将回调函数注册进去，当healthMonitor检测到节点状态变化时，利用回调方法通知ZKFailoverController，然后ZKFailoverController使用ActiveStandyElector发起主从选举，当选举结果出来时，ActiveStandyElector将使用注册进去的回调方法通知ZKFailoverController，ZKFailoverController将其转化为Active/Standy Node。</p><h2><span id="healthmonitor介绍">HealthMonitor介绍</span></h2><p>​         主备切换控制器（ZKFailoverController ）在初始化时会创建 HealthMonitor，HealthMonitor 在内部会启动一个线程来循环调用 NameNode 的 HAServiceProtocol RPC 接口的方法来检测 NameNode 的状态，并将状态的变化通过回调的方式来通知 ZKFailoverController。HealthMonitor类包含一个内部类MonitorDaemon,MonitorDaemon是一个守护进程程序，会随着系统一起启动，在系统运行期间循环、周期地向HA SERVICE发送心跳包，与服务保持联系，当服务的健康状况发生改变时，通知failover controller。HealthMonitor主要检测 NameNode 的两类状态，分别是 HealthMonitor.State 和 HAServiceStatus（如下所述）.                                                                                                                                                                                                                          </p><p>HealthMonitor包括以下内容</p><ol><li>MonitorDaemon 守护进程程序，会在HealthMonitor启动时start，在与HA-service连接成功前一直循环，随后检查并并监听服务的健康状况，当服务的健康状况发生改变时，通知failover controller，以上是通过HAServiceProtocol实现的。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (shouldRun) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123; </span><br><span class="line">      loopUntilConnected();</span><br><span class="line">      doHealthChecks();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">      Preconditions.checkState(!shouldRun,</span><br><span class="line">          <span class="string">"Interrupted but still supposed to run"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>HAServiceProtocol 扮演代理角色，负责与HA-service连接，检查健康</li><li>HAServiceTarget 被监控的service</li><li>HealthMonitor.State   service的健康状态，有以下几种</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">INITIALIZING (<span class="string">"检查器正在初始化"</span>)</span><br><span class="line">SERVICE_NOT_RESPONDING (<span class="string">"service没有回应，没有成功connect"</span>) </span><br><span class="line">SERVICE_HEALTHY(<span class="string">"与service成功连接且健康"</span>),</span><br><span class="line">SERVICE_UNHEALTHY(<span class="string">"成功连接但不健康"</span>)</span><br><span class="line">HEALTH_MONITOR_FAILED (<span class="string">"检查器本身故障，无法继续检查"</span>)</span><br></pre></td></tr></table></figure><ol start="5"><li>callback 当HealthMonitor.State发生变化时，执行回调方法，通知ZKFailoverController做相关处理</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">enterState</span><span class="params">(State newState)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (newState != state) &#123;</span><br><span class="line">    LOG.info(<span class="string">"Entering state &#123;&#125;"</span>, newState);</span><br><span class="line">    state = newState;</span><br><span class="line">    <span class="keyword">synchronized</span> (callbacks) &#123;</span><br><span class="line">      <span class="keyword">for</span> (Callback cb : callbacks) &#123;</span><br><span class="line">        cb.enteredState(newState);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li>ServiceStateCallback 当检查到service的HAServiceStatus发生变化时，通知ZKFailoverController，HAServiceStatus反应了HA状态，具体如下</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">INITIALIZING(<span class="string">"initializing"</span>),</span><br><span class="line">ACTIVE(<span class="string">"active"</span>),</span><br><span class="line">STANDBY(<span class="string">"standby"</span>),</span><br><span class="line">STOPPING(<span class="string">"stopping"</span>);</span><br></pre></td></tr></table></figure><p><strong>以下是HealthMonitor的调用过程，当控制器将callback回调控制器的方法后，控制器将通过主从选举器进行选举</strong></p><h2><span id="activestandbyelector">ActiveStandbyElector</span></h2><p>​        ActiveStandbyElector借助zookeeper的写一致性和临时节点机制来实现leader选举，最终只有一个实例能够成功创建临时节点，这个实例对应的namenode将成为leader，其他的成为从节点。当选取出结果时，ActiveStandbyElector 会回调 ZKFailoverController 的方法，然后ZKFailoverController将对应的 NameNode 切换为active/ Standby 状态。</p><h3><span id="activestandbyelector初始化">ActiveStandbyElector初始化</span></h3><p>创建一个ActiveStandbyElector对象，会创建与zk的连接并注册watcher监听，WatcherWithClientRef watcher，调用watcher的waitForZKConnectionEvent（）来监控事件（主要关注connection and node event）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ActiveStandbyElector</span><span class="params">(String zookeeperHostPorts,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">int</span> zookeeperSessionTimeout, String parentZnodeName, List&lt;ACL&gt; acl,</span></span></span><br><span class="line"><span class="function"><span class="params">      List&lt;ZKAuthInfo&gt; authInfo, ActiveStandbyElectorCallback app,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">int</span> maxRetryNum)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> ZooKeeper <span class="title">connectToZooKeeper</span><span class="params">()</span> <span class="keyword">throws</span> IOException,</span></span><br><span class="line"><span class="function">      KeeperException </span>&#123;</span><br><span class="line">    watcher = <span class="keyword">new</span> WatcherWithClientRef();</span><br><span class="line">    ZooKeeper zk = createZooKeeper();</span><br><span class="line">    watcher.setZooKeeperRef(zk);</span><br><span class="line">    watcher.waitForZKConnectionEvent(zkSessionTimeout);</span><br><span class="line">    <span class="keyword">for</span> (ZKAuthInfo auth : zkAuthInfo) &#123;</span><br><span class="line">      zk.addAuthInfo(auth.getScheme(), auth.getAuth());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> zk;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3><span id="创建锁节点and主从选举">创建锁节点and主从选举</span></h3><p>​      当HealthMonitor检测到对应的NameNode的状态正常，那么表示这个NameNode有资格参加Zookeeper的主备选举。如果目前还没有进行过主备选举的话，那么相应的ActiveStandbyElector就会发起一次主备选举，尝试在Zookeeper上创建一个路径为/hadoop-ha/${dfs.nameservices}/ActiveStandbyElectorLock的临时节点，Zookeeper的写一致性会保证最终只会有一个ActiveStandbyElector创建成功，成功创建的ActiveStandbyElector对应的NameNode就会被选举为主节点，然后ActiveStandbyElector会回调ZKFailoverController的方法，ZKFailoverController将对应的NameNode切换为Active状态。如果ZKFailoverController切换状态失败，会转为从节点并重新加入选举；而创建失败的 ActiveStandbyElector对应的NameNode被选举为备NameNode，ActiveStandbyElector会回调ZKFailoverController的方法进一步将对应的NameNode切换为Standby状态。无论最终切换为什么节点，都会继续监控activeNameNode。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//interface implementation of Zookeeper callback for create</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">if</span> (LOG.isDebugEnabled()) &#123;</span><br><span class="line">  LOG.debug(<span class="string">"CreateNode result: "</span> + rc + <span class="string">" for path: "</span> + path</span><br><span class="line">      + <span class="string">" connectionState: "</span> + zkConnectionState +</span><br><span class="line">      <span class="string">"  for "</span> + <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">Code code = Code.get(rc);</span><br><span class="line"><span class="keyword">if</span> (isSuccess(code)) &#123;</span><br><span class="line">  <span class="comment">// we successfully created the znode. we are the leader. start monitoring</span></span><br><span class="line">  <span class="keyword">if</span> (becomeActive()) &#123;</span><br><span class="line">    monitorActiveStatus();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    reJoinElectionAfterFailureToBecomeActive();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isNodeExists(code)) &#123;</span><br><span class="line">  <span class="keyword">if</span> (createRetryCount == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// znode exists and we did not retry the operation. so a different</span></span><br><span class="line">    <span class="comment">// instance has created it. become standby and monitor lock.</span></span><br><span class="line">    becomeStandby();</span><br><span class="line">  &#125;</span><br><span class="line">  monitorActiveStatus();</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="watcher监听nodedelete事件">watcher监听NodeDELETE事件</span></h3><p>当active nameNode所在机器发生故障时，临时节点将被删掉。此时watcher将会处理事件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">  hasReceivedEvent.countDown();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!hasSetZooKeeper.await(zkSessionTimeout, TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">      LOG.debug(<span class="string">"Event received with stale zk"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ActiveStandbyElector.<span class="keyword">this</span>.processWatchEvent(</span><br><span class="line">        zk, event);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">    fatalError(</span><br><span class="line">        <span class="string">"Failed to process watcher event "</span> + event + <span class="string">": "</span> +</span><br><span class="line">        StringUtils.stringifyException(t));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当监听到connection和node 事件时，watcher会执行一些操作，这里只讨论NodeDeleted，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * interface implementation of Zookeeper watch events (connection and node),</span></span><br><span class="line"><span class="comment">   * proxied by &#123;<span class="doctag">@link</span> WatcherWithClientRef&#125;.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">String path = event.getPath();</span><br><span class="line">    <span class="keyword">if</span> (path != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">switch</span> (eventType) &#123;</span><br><span class="line">      <span class="keyword">case</span> NodeDeleted:</span><br><span class="line">        <span class="keyword">if</span> (state == State.ACTIVE) &#123;</span><br><span class="line">          enterNeutralMode();</span><br><span class="line">        &#125;</span><br><span class="line">        joinElectionInternal();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> NodeDataChanged:</span><br><span class="line">        monitorActiveStatus();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">if</span> (LOG.isDebugEnabled()) &#123;</span><br><span class="line">          LOG.debug(<span class="string">"Unexpected node event: "</span> + eventType + <span class="string">" for path: "</span> + path);</span><br><span class="line">        &#125;</span><br><span class="line">        monitorActiveStatus();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br></pre></td></tr></table></figure><h3><span id="脑裂问题">脑裂问题</span></h3><p>如果 Zookeeper 客户端机器overload，可能会导致 Zookeeper client到 Zookeeper server的心跳包不能正常发出，一旦这个时间超过了 Zookeeper Session Timeout，Zookeeper server就会认为client的 session 已经过期，将客户端的 Session 关闭从而引起脑裂 (brain-split) 现象。</p><p>当发生脑裂时，activeNode的临时节点会被删除，从而唤醒其他服务进行选举，产生新的activeNode。但此时oldNode 可能仍然处于 Active 状态正常运行。对应的 ZKFailoverController 负载下降而恢复正常后，虽然知到自己和 Zookeeper 的 Session 已经关闭，但是由于网络延迟以及 CPU 线程调度的不确定性，仍然有可能会在接下来的一段时间窗口内认为自己还是处于 Active 状态，这样oldActiveNode和 newActiveNode都处于 Active 状态，都可以对外提供服务。这种情况对于 NameNode 这类对数据一致性要求非常高的系统来说是灾难性的，数据会发生错乱且无法恢复。Zookeeper 社区的应对方案是 fencing(隔离)：把旧的 Active NameNode 隔离，使之不能正常对外提供服务。</p><p><strong>ActiveStandbyElector会在选举为主节点时，创建一个持久节点/hadoop-ha/${dfs.nameservices}/ActiveBreadCrumb，这个节点里面保存了这个 Active NameNode 的地址信息</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在选举为主节点时，会创建一个持久节点</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">becomeActive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">assert</span> wantToBeInElection;</span><br><span class="line">  <span class="keyword">if</span> (state == State.ACTIVE) &#123;</span><br><span class="line">    <span class="comment">// already active</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    Stat oldBreadcrumbStat = fenceOldActive();<span class="comment">//回调方法，返回old active node</span></span><br><span class="line">    writeBreadCrumbNode(oldBreadcrumbStat);</span><br><span class="line">    LOG.debug(<span class="string">"Becoming active for &#123;&#125;"</span>, <span class="keyword">this</span>);</span><br><span class="line">    appClient.becomeActive();</span><br><span class="line">    state = State.ACTIVE;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    LOG.warn(<span class="string">"Exception handling the winning of election"</span>, e);</span><br><span class="line">    <span class="comment">// Caller will handle quitting and rejoining the election.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果 breadcrumb node 存在，表明有oldActiveNode需要隔离, 调用ZKFailoverController的方法去隔离,返回stat(非null)，如果breadcrumb node不存在，返回null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Stat <span class="title">fenceOldActive</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, KeeperException </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Stat stat = <span class="keyword">new</span> Stat();</span><br><span class="line">  <span class="keyword">byte</span>[] data;</span><br><span class="line">  LOG.info(<span class="string">"Checking for any old active which needs to be fenced..."</span>);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    data = zkDoWithRetries(<span class="keyword">new</span> ZKAction&lt;<span class="keyword">byte</span>[]&gt;() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">byte</span>[] run() <span class="keyword">throws</span> KeeperException, InterruptedException &#123;</span><br><span class="line">        <span class="keyword">return</span> zkClient.getData(zkBreadCrumbPath, <span class="keyword">false</span>, stat);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (KeeperException ke) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isNodeDoesNotExist(ke.code())) &#123;</span><br><span class="line">      LOG.info(<span class="string">"No old node to fence"</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// If we failed to read for any other reason, then likely we lost</span></span><br><span class="line">    <span class="comment">// our session, or we don't have permissions, etc. In any case,</span></span><br><span class="line">    <span class="comment">// we probably shouldn't become active, and failing the whole</span></span><br><span class="line">    <span class="comment">// thing is the best bet.</span></span><br><span class="line">    <span class="keyword">throw</span> ke;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  LOG.info(<span class="string">"Old node exists: &#123;&#125;"</span>, StringUtils.byteToHexString(data));</span><br><span class="line">  <span class="keyword">if</span> (Arrays.equals(data, appData)) &#123;</span><br><span class="line">    LOG.info(<span class="string">"But old node has our own data, so don't need to fence it."</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    appClient.fenceOldActive(data);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> stat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果old activeNode不存在，创建持久节点；否则更新node</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeBreadCrumbNode</span><span class="params">(Stat oldBreadcrumbStat)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> KeeperException, InterruptedException </span>&#123;</span><br><span class="line">  Preconditions.checkState(appData != <span class="keyword">null</span>, <span class="string">"no appdata"</span>);</span><br><span class="line">  </span><br><span class="line">  LOG.info(<span class="string">"Writing znode &#123;&#125; to indicate that the local "</span> +</span><br><span class="line">      <span class="string">"node is the most recent active..."</span>, zkBreadCrumbPath);</span><br><span class="line">  <span class="keyword">if</span> (oldBreadcrumbStat == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// No previous active, just create the node</span></span><br><span class="line">    createWithRetries(zkBreadCrumbPath, appData, zkAcl,</span><br><span class="line">      CreateMode.PERSISTENT);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    setDataWithRetries(zkBreadCrumbPath, appData, oldBreadcrumbStat.getVersion());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        </p><h2><span id="zkfailovercontroller介绍">ZKFailoverController介绍</span></h2><p>​        主备切换控制器 (ZKFailoverController )作为独立的进程运行，与HealthMonitor 、ActiveStandbyElector两大组件一起对 NameNode 的主备切换进行控制。它启动时，会初始化ActiveStandyElector和healthMonitor,并将回调函数注册进去，当healthMonitor检测到节点状态变化时，利用回调方法通知ZKFailoverController，然后ZKFailoverController使用ActiveStandyElector发起主从选举，当选举结果出来时，ActiveStandyElector将使用注册进去的回调方法通知ZKFailoverController，ZKFailoverController将其转化为Active/Standy Node。</p><ol><li>ZKFailoverController的初始化时会initZK，构造ActiveStandyElector</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initZK</span><span class="params">()</span> <span class="keyword">throws</span> HadoopIllegalArgumentException, IOException,</span></span><br><span class="line"><span class="function">    KeeperException </span>&#123;</span><br><span class="line">  zkQuorum = conf.get(ZK_QUORUM_KEY);</span><br><span class="line">  <span class="keyword">int</span> zkTimeout = conf.getInt(ZK_SESSION_TIMEOUT_KEY,</span><br><span class="line">      ZK_SESSION_TIMEOUT_DEFAULT);</span><br><span class="line">  <span class="comment">// Parse ACLs from configuration.</span></span><br><span class="line">  String zkAclConf = conf.get(ZK_ACL_KEY, ZK_ACL_DEFAULT);</span><br><span class="line">  zkAclConf = ZKUtil.resolveConfIndirection(zkAclConf);</span><br><span class="line">  List&lt;ACL&gt; zkAcls = ZKUtil.parseACLs(zkAclConf);</span><br><span class="line">  <span class="keyword">if</span> (zkAcls.isEmpty()) &#123;</span><br><span class="line">    zkAcls = Ids.CREATOR_ALL_ACL;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Parse authentication from configuration.</span></span><br><span class="line">  List&lt;ZKAuthInfo&gt; zkAuths = SecurityUtil.getZKAuthInfos(conf, ZK_AUTH_KEY);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Sanity check configuration.</span></span><br><span class="line">  Preconditions.checkArgument(zkQuorum != <span class="keyword">null</span>,</span><br><span class="line">      <span class="string">"Missing required configuration '%s' for ZooKeeper quorum"</span>,</span><br><span class="line">      ZK_QUORUM_KEY);</span><br><span class="line">  Preconditions.checkArgument(zkTimeout &gt; <span class="number">0</span>,</span><br><span class="line">      <span class="string">"In</span></span><br><span class="line"><span class="string">  int maxRetryNum = conf.getInt(</span></span><br><span class="line"><span class="string">      CommonConfigurationKeys.HA_FC_ELECTOR_ZK_OP_RETRIES_KEY,</span></span><br><span class="line"><span class="string">      CommonConfigurationKeys.HA_FC_ELECTOR_ZK_OP_RETRIES_DEFAULT);</span></span><br><span class="line"><span class="string">  elector = new ActiveStandbyElector(zkQuorum,</span></span><br><span class="line"><span class="string">      zkTimeout, getParentZnode(), zkAcls, zkAuths,</span></span><br><span class="line"><span class="string">      new ElectorCallbacks(), maxRetryNum);</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>​    <strong>initZK时创建了ActiveStandyElector，并将回调类注册进去，方便ActiveStandyElector监听</strong>，</p><ol><li>ZKFailoverController的初始化时，会initHealthMonitor</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initHM</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  healthMonitor = <span class="keyword">new</span> HealthMonitor(conf, localTarget);</span><br><span class="line">  healthMonitor.addCallback(<span class="keyword">new</span> HealthCallbacks());</span><br><span class="line">  healthMonitor.addServiceStateCallback(<span class="keyword">new</span> ServiceStateCallBacks());</span><br><span class="line">  healthMonitor.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>initHM时，将回调对象注册进去，当HM监听到状态变化时，利用回调函数通知控制器</li><li>当HM执行回调方法enterState（newState）时，控制器使用主从选择器让该节点进入/退出选举</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Callbacks from HealthMonitor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HealthCallbacks</span> <span class="keyword">implements</span> <span class="title">HealthMonitor</span>.<span class="title">Callback</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enteredState</span><span class="params">(HealthMonitor.State newState)</span> </span>&#123;</span><br><span class="line">    setLastHealthState(newState);</span><br><span class="line">    recheckElectability();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Check the current state of the service, and join the election</span></span><br><span class="line"><span class="comment">   * if it should be in the election.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">recheckElectability</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Maintain lock ordering of elector -&gt; ZKFC</span></span><br><span class="line">    <span class="keyword">synchronized</span> (elector) &#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> healthy = lastHealthState == State.SERVICE_HEALTHY;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">long</span> remainingDelay = delayJoiningUntilNanotime - System.nanoTime(); </span><br><span class="line">        <span class="keyword">if</span> (remainingDelay &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (healthy) &#123;</span><br><span class="line">            LOG.info(<span class="string">"Would have joined master election, but this node is "</span> +</span><br><span class="line">                <span class="string">"prohibited from doing so for "</span> +</span><br><span class="line">                TimeUnit.NANOSECONDS.toMillis(remainingDelay) + <span class="string">" more ms"</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          scheduleRecheck(remainingDelay);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">switch</span> (lastHealthState) &#123;</span><br><span class="line">        <span class="keyword">case</span> SERVICE_HEALTHY:</span><br><span class="line">          elector.joinElection(targetToData(localTarget));</span><br><span class="line">          <span class="keyword">if</span> (quitElectionOnBadState) &#123;</span><br><span class="line">            quitElectionOnBadState = <span class="keyword">false</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">          </span><br><span class="line">        <span class="keyword">case</span> INITIALIZING:</span><br><span class="line">          LOG.info(<span class="string">"Ensuring that "</span> + localTarget + <span class="string">" does not "</span> +</span><br><span class="line">              <span class="string">"participate in active master election"</span>);</span><br><span class="line">          elector.quitElection(<span class="keyword">false</span>);</span><br><span class="line">          serviceState = HAServiceState.INITIALIZING;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">case</span> SERVICE_UNHEALTHY:</span><br><span class="line">        <span class="keyword">case</span> SERVICE_NOT_RESPONDING:</span><br><span class="line">          LOG.info(<span class="string">"Quitting master election for "</span> + localTarget +</span><br><span class="line">              <span class="string">" and marking that fencing is necessary"</span>);</span><br><span class="line">          elector.quitElection(<span class="keyword">true</span>);</span><br><span class="line">          serviceState = HAServiceState.INITIALIZING;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">          </span><br><span class="line">        <span class="keyword">case</span> HEALTH_MONITOR_FAILED:</span><br><span class="line">          fatalError(<span class="string">"Health monitor failed!"</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">          </span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unhandled state:"</span></span><br><span class="line">                                               + lastHealthState);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>选举器在选举结束后，会在processXXX（）回调控制器的方法，通知控制器选举完成，然后控制器通过HAServiceProtocol的rpc调用将对应的节点变为主/从节点</p><h3><span id="总结">总结</span></h3><p><img src="https://www.ibm.com/developerworks/cn/opensource/os-cn-hadoop-name-node/img002.png" alt="NameNode主从切换的过程"></p><p>​                                    <a href="http://www.boren33.com/2018/08/22/NameNode%E4%B8%BB%E5%A4%87%E5%88%87%E6%8D%A2/">图片引自</a></p><h3><span id="注意事项">注意事项</span></h3><p>**最后需要注意的是这个选举机制只有当候选节点较少时才有效（order of 10’s），因为大量候选者连接zookeeper的同一个节点会导致zookeeper过载。</p>]]></content>
      
      <categories>
          
          <category> 技术人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hadoop </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>新梦想</title>
      <link href="/%E6%96%B0%E6%A2%A6%E6%83%B3.html"/>
      <url>/%E6%96%B0%E6%A2%A6%E6%83%B3.html</url>
      <content type="html"><![CDATA[<p>2018刚好过半，敬往事一杯酒，致新梦想以微笑。</p><p>新时代，新梦想，愿你在未来的每一天，不因过去而悔恨，只因今天而骄傲，加油。</p>]]></content>
      
      <categories>
          
          <category> 往事随风 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>简聊JAVA NIO</title>
      <link href="/%E7%AE%80%E8%81%8AJAVA-NIO.html"/>
      <url>/%E7%AE%80%E8%81%8AJAVA-NIO.html</url>
      <content type="html"><![CDATA[<p>java NIO（non blocking IO），是一种同步非阻塞IO，为IO多路复用的基础，适用于高并发与大量连接，主要由三大组件构成：channel、Buffer、Selector，虽然还有一些其他组件，如管道，但大多是基于这三大组件而构造的。<br>   <a id="more"></a></p><h1><span id="channel">channel</span></h1><p>  与java BIO 数据流单向传输不同的是，NIO中引入了channel，它可以双向传输，既可以将数据通过缓冲写入到channel中，也可以将channel中的数据读入缓存。常见的channel类型有</p><p>  FileChannel（阻塞，无法结合selector使用）<br>  DatagramChannel<br>  SocketChannel<br>  ServerSocketChannel</p><h1><span id="buffer">Buffer</span></h1><p>   缓冲Buffer容易理解，就是把读取到的数据放入一个或多个池中，等池子满了，可以一次拿走；或者将数据分别放到不同的池中，一次性传输到channel中。而不必多次运输。<br>   Buffer中有四个属性：mark、capacity、position、limit。</p><p>  <img src="/images/buffer.png" alt="buffer原理"></p><h3><span id="mark">mark</span></h3><p>初始值为-1，用于备份当前的position  </p><h3><span id="capacity">capacity</span></h3><p>capacity代表缓冲池的大小，当缓冲池满了，需要将其清空（通过读数据或者清除数据）才能继续往里写数据。</p><h3><span id="position">position</span></h3><p>position表示当前读/写的位置。<br>写模式中，position初始为0，当往缓冲池写入一个byte、long等数据时，postion会移到下一个可写的位置。<br>从写模式切换到读模式时，position重置为0，每读取一个数据，position会向前移动到下一个可读的位置</p><h3><span id="limit">limit</span></h3><p>在写模式下，Buffer的limit表示你最多能往Buffer里写多少数据（等于capacity）。当切换Buffer到读模式时，limit表示你最多能读到多少数据。因此，当切换Buffer到读模式时，limit会被设置成写模式下的position值。即之前写入的所有数据。</p><h2><span id="方法">方法</span></h2><p>mark()：把当前的position赋值给mark<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">mark</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mark = position;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>reset()：把mark值还原给position<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = mark;</span><br><span class="line">    <span class="keyword">if</span> (m &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InvalidMarkException();</span><br><span class="line">    position = m;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>clear()：一旦读完Buffer中的数据，需要让Buffer准备好再次被写入，clear会恢复状态值，但不会擦除数据。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    position = <span class="number">0</span>;</span><br><span class="line">    limit = capacity;</span><br><span class="line">    mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>flip()：Buffer有两种模式，写模式和读模式，flip后Buffer从写模式变成读模式。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">flip</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    limit = position;</span><br><span class="line">    position = <span class="number">0</span>;</span><br><span class="line">    mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>rewind()：重置position为0，从头读写数据。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">rewind</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    position = <span class="number">0</span>;</span><br><span class="line">    mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2><span id="分散聚集-scattergather">分散/聚集 Scatter/Gather</span></h2><p>Scatter（分散）：将一个channel的数据分散到多个缓存池中；<br>Gather：将多个缓冲池中的数据写入一个channel。<br>前者在将数据写入到下一个缓冲池前必须先将第一个池子填满，，而后者只能将position和limit之间的数据写入channel。因此前者不适合将大小不固定的消息读入多个缓冲池中，如消息体和消息消息头。后者适合写入灵活大小的消息，如把数据分为两部分，分别存放在headerBuffer和bodyBuffer中。</p><h1><span id="selector">selector</span></h1><p>想象一个场景：一个酒店服务员，负责好几个房间，每个房间住房、退房，她都会登记，这样当我们想知道某个房间的入住情况时，直接问这个服务员就好；<br>在selector模型中，每个channel相当于一个房间，selector相当于上述的服务员，线程可以通过一个selector监听多个channel的状态，在每个channel有相关事件就绪时，返回函数。需要知道的是</p><ol><li>selector是非阻塞的，所以阻塞channel（FileChannel）无法与他搭配使用。</li><li>需要让selector管理的channel必须先注册<br>   channel.register(selector,interstOps);<br>第二个参数代表selector对channel的什么事情感兴趣</li><li>要知道是否有channel事件就休可以调用select方法;返回值<br> 表示多少个channel事件就绪：<br> select()一直阻塞，直到事件就绪<br> select（long time），规定时间内channel没有事件就绪，直接返回0，<br>  seectNow()不会阻塞，不管什么通道就绪都立刻返回.</li><li><p>在select方法返回数据后，可以通过 selectedKeys()查看事件详情，SelectionKey结构如下：</p><ul><li><p>SelectionKey中定义了四个常量来表示事件</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">OP_READ = <span class="number">1</span> &lt;&lt; <span class="number">0</span>;</span><br><span class="line">OP_WRITE = <span class="number">1</span> &lt;&lt; <span class="number">2</span>;</span><br><span class="line">OP_CONNECT = <span class="number">1</span> &lt;&lt; <span class="number">3</span>;</span><br><span class="line">OP_ACCEPT = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br></pre></td></tr></table></figure></li><li><p>感兴趣的事件的集（或运算计算得a|b|c）             </p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> SelectionKey <span class="title">interestOps</span><span class="params">(<span class="keyword">int</span> ops)</span></span>;<span class="comment">//</span></span><br></pre></td></tr></table></figure></li><li><p>已就绪的事件，可能多个，这样我们就可以判断当前channel是否可读/写/连接等</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">readyOps</span><span class="params">()</span></span>;</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isReadable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (readyOps() &amp; OP_READ) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isWritable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (readyOps() &amp; OP_WRITE) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h1><span id="实例">实例</span></h1><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Selector selector = Selector.open();</span><br><span class="line">channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">SelectionKey key = channel.register(selector, SelectionKey.OP_READ);</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">  <span class="keyword">int</span> readyChannels = selector.select();</span><br><span class="line">  <span class="keyword">if</span>(readyChannels == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">  Set selectedKeys = selector.selectedKeys();</span><br><span class="line">  Iterator keyIterator = selectedKeys.iterator();</span><br><span class="line">  <span class="keyword">while</span>(keyIterator.hasNext()) &#123;</span><br><span class="line">    SelectionKey key = keyIterator.next();</span><br><span class="line">    <span class="keyword">if</span>(key.isAcceptable()) &#123;</span><br><span class="line">        <span class="comment">// a connection was accepted by a ServerSocketChannel.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isConnectable()) &#123;</span><br><span class="line">        <span class="comment">// a connection was established with a remote server.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">        <span class="comment">// a channel is ready for reading</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isWritable()) &#123;</span><br><span class="line">        <span class="comment">// a channel is ready for writing</span></span><br><span class="line">    &#125;</span><br><span class="line">    keyIterator.remove();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><h1><span id="nio-优缺点">NIO 优缺点</span></h1><ul><li>单线程可以处理多任务，多线程可以处理更多的连接，节省了线程开支</li><li>socket主要的读、写、注册和接收函数，在等待就绪阶段都是非阻塞的，只有在I/O操作时是同步阻塞的（消耗CPU但性能非常高）</li><li>基于block的传输，通常比基于流的传输更高效</li><li><p>IO多路复用大大提高了Java网络应用的可伸缩性和实用性</p></li><li><p>并发程度不高或者局域网环境下NIO并没有显著的性能优势。</p></li><li>NIO没有完全屏蔽平台差异，各平台的实现存在差异。使用NIO做网络编程构建事件驱动模型并不容易。</li></ul><p>参考资料 <a href="http://tutorials.jenkov.com/java-nio/overview.html" target="_blank" rel="noopener">http://tutorials.jenkov.com/java-nio/overview.html</a></p>]]></content>
      
      <categories>
          
          <category> 技术人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IO </tag>
            
            <tag> NIO </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>给过去的一封信</title>
      <link href="/%E7%BB%99%E8%BF%87%E5%8E%BB%E7%9A%84%E4%B8%80%E5%B0%81%E4%BF%A1.html"/>
      <url>/%E7%BB%99%E8%BF%87%E5%8E%BB%E7%9A%84%E4%B8%80%E5%B0%81%E4%BF%A1.html</url>
      <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>痛苦要么成就一个人,要么彻底摧毁他!</strong><br><a id="more"></a></p><h2><span id="遗憾过去">遗憾过去</span></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;世界上最痛苦的事从不是我无法做到,而是我本可以…人们容易陷入过往的悔恨中,理由太多了,比如儿时的不懂事,为现在未来埋下祸根,亦是回眸之间,错过最重要的人,或者是包括过去的不努力,这些往往是相辅相成,不可分割,共同组成你的心魔.</p><h2><span id="为什么要放下过去">为什么要放下过去?</span></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;曾经我问世界:命运是什么?它告诉我:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个人的命运不只是指他的天赋和出身，还包括那些”早年的经历”。在思想不成熟的时期，我们有可能无意识地犯下大错，从此影响了一生！这些都是不可控的。它叫作命运！命运无需在意，就像童年犯错一样。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而当我们真正明白并接受自己的过去后，我们就长大了，剩下的人生就不存在命运之说，此时的生活是事在人为，我们只需大胆追求想要得一切!<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对,在你走出来之前,你那些看似愚蠢的错误确实是一种命,当你想明白后,过去的你随过往时光都烟消云散,既然当初的自己随着过往都死了,那又与你何干</p><h2><span id="如何放下过去">如何放下过去.</span></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>别想一下就改变</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>别想没用的</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>别让自己的惯性思维害了自己</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;人总是在痛苦中不断成长,期间可能是无限循环的,直到一个时刻,这个条件被打破.这几天回顾了下过去的生活,发现自己始终没有真正走出来,亦无法全心全意的工作,这也困扰了我太多,越是这样越是愤恨自己,zui’hou发现了这么一个规矩:</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>一直做(想)一件事非常容易,但想打破这个状态时会异常难,这叫惯性.</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么是不是无法改变呢?当然不是,当我们开始一件新事物时,脑海中会有各种杂念,但是如果你足够意志坚定,这种抵触思维会慢慢消退.第一次可能痛苦好几天,第二次痛苦一两天,第三天几个小时,再到最后每次持续几分钟甚至几秒.到了后期,你会发现你战胜了过去的自己.一切似乎不可思议.长此以往,你就变得不再是当初的自己</p>]]></content>
      
      <categories>
          
          <category> 往事随风 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>遇见美丽</title>
      <link href="/%E9%81%87%E8%A7%81%E7%BE%8E%E4%B8%BD.html"/>
      <url>/%E9%81%87%E8%A7%81%E7%BE%8E%E4%B8%BD.html</url>
      <content type="html"><![CDATA[<p>生活不止眼前的苟且,还有诗和远方的田野<br>你赤手空拳来到人世间,为找到那片海不顾一切<br>当我寻找光明的时候，不小心陷入黑暗<br>迷茫，痛苦，懊悔，绝望…<a id="more"></a><br>我在蓝色的天空，策马奔腾<br>懊悔，愤怒，嘶吼，战斗<br>终于找到生命的奥秘<br>我告诉自己何为理想，何为生活<br>我以为自己没有快乐,更不再有悲伤<br>我似乎失去感知所有的能力<br>直到,<br>清风徐来，我遇见你，<br>这颗沉默的心开始颤抖<br>因为过分美丽，所以无限挣扎<br>回眸瞬间，错过风雨！<br>我告诉自己<br>如果疼痛无法治愈，就用血色谱写光阴。<br>终何去何从，请听何为<a href="https://www.zhihu.com/question/265653002/answer/296655901" target="_blank" rel="noopener">命运</a></p>]]></content>
      
      <categories>
          
          <category> 往事随风 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>向左乐观,向右悲观</title>
      <link href="/%E5%90%91%E5%B7%A6%E4%B9%90%E8%A7%82,%E5%90%91%E5%8F%B3%E6%82%B2%E8%A7%82.html"/>
      <url>/%E5%90%91%E5%B7%A6%E4%B9%90%E8%A7%82,%E5%90%91%E5%8F%B3%E6%82%B2%E8%A7%82.html</url>
      <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;人生本就是马拉松,有的人历经挫折,依然潇洒,有些人从未经历,却彷徨不前.仔细观察,不过是心在作怪.而如果把一生比作函数,我们会发现一个有趣的现象:</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;掉入局部最大值的时候，人们知道这不是全局最大的，<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;掉入局部最小值时，人们总觉得这是全局最小值</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此想要快乐的活着,最关键的还是要<strong>突破思维</strong>,改变自己!</p>]]></content>
      
      <categories>
          
          <category> 往事随风 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>排序算法总结</title>
      <link href="/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.html"/>
      <url>/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.html</url>
      <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;排序,顾名思义,将数据按照某种规则排列起来.这种规则可以是根据基本的数值大小排序,也可以是通过字符串长度比较来排序,又或者是优先根据两个字符串的第一个不同值为参考来比较的排序(String的compareTo默认方法),而这个规则可以是各式各样的,你可以根据义务来自己定制排序策略,今天我们主要探讨数据结构与算法中8中基本的排序算法(全部根据数值大小比较)</p>]]></content>
      
      <categories>
          
          <category> 技术人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>人生传</title>
      <link href="/%E4%BA%BA%E7%94%9F%E4%BC%A0.html"/>
      <url>/%E4%BA%BA%E7%94%9F%E4%BC%A0.html</url>
      <content type="html"><![CDATA[<p>如果人生是一场炼狱,那我们何去何从<br>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;—&lt;&lt;魔也,道也&gt;&gt;</p><a id="more"></a><h2><span id="出入尘世天真无邪">出入尘世,天真无邪</span></h2><p>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;童年的我特别乖,有一次奶奶的救心丸找不到了,斥责我是不是偷去玩了,自己死活不肯承认,后来看她越来越急,就说”别找了,本少爷玩丢了”,然后就是一顿毒打….过了几天,救心丸出现在了奶奶的药盒.<br>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;小时候,村里就一个老师,同时教幼儿园到小学3年级,作为当代最小屁孩,我跟着大屁孩们一起上课,当时自己总是喜欢研究一些数学”怪题”,结局也都不错,但是特别讨厌学语文,可惜不背课文不让吃饭,于是我就特别认真的背,记得当时把几本书从头到尾背完,接着反着背,因此拿到5块钱巨款作为零花钱.</p><h2><span id="无关对错只为快乐">无关对错,只为快乐</span></h2><p>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;过去10-15年,大多数中国农村家庭十分贫穷,我家也不例外,曾经的梦想是拥有一台电脑,玩一辈子问道.还记得以前经常饿肚子,但是一玩游戏或者想象自己在玩游戏,就变得精神抖擞,这一直持续了七年,在很多人眼里这是荒废,不务正业,但它确实是一生中最纯净的时光,这就是信仰的力量吧.直到读了乔布斯传,身体的血液开始燃烧,觉得我应该改变自己,于是开始好好学习</p><h2><span id="悔恨犹在何去何从">悔恨犹在,何去何从</span></h2><p>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我的高中很不快乐,经常一个人在操场散步,或者回到教室装睡,然后沉思,时间长了,变本加厉,总是处于对过去的不满和自身的懊悔中,我从不惧怕未来,却不能接受过去,越是走不出来,浪费越多时间,时间越长,自责更深,恶性循环,此时我已从当年反应敏捷的儿童变成略有迟钝的少年.这些事情让人如此痛苦,以至于我不得不”先解决心情,再解决事情”.我找了大量心理学书,结果根本没耐心看,全理论知识,仿佛是一本本教科书.废话连篇.直到后来慢慢明白痛苦是正常的,一个人承受越大的痛苦,未来可以抗住越大的打击.,相反一个没有过痛苦和思考的人,他的一生得多普通啊?</p><h2><span id="如梦初醒大步朝前">如梦初醒,大步朝前</span></h2><p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;黑暗光明,黑暗光明,黑暗光明,惶惶中6年时间过去,已不再是当初的少年,这时更清楚自己想成为什么样的人,我开始朝着自己的梦想(兼具艺术和技术的优秀工程师)逐步努力.此时已是大二下学期.每天不去上课,沉迷于图书馆,看着妹子,刷着一道道算法题,每次accept,都触动着内心,看编译原理时,也总是惊呼原来如此,学习计网时,从一开始的认为理所当然到知其所以然都是一种兴奋,研读jdk源码时,从一开始的懵逼到初为了解,再到懵逼,再到了解..不得不感叹大佬的智慧.终于结果是美丽的,春招拿到一些互联网公司offer,最后去了小米科技(Mi fan),做push服务端开发</p><h2><span id="面朝大海春暖花开">面朝大海,春暖花开</span></h2><p>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一花一世界，一叶一如来.这个世界无所谓缺陷，即使是缺陷，也是美的.让我们朝着梦想前进</p>]]></content>
      
      <categories>
          
          <category> 往事随风 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
