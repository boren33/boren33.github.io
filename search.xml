<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>test</title>
      <link href="/test.html"/>
      <url>/test.html</url>
      <content type="html"><![CDATA[]]></content>
      
      
    </entry>
    
    <entry>
      <title>HDFS高可用性介绍</title>
      <link href="/HDFS%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7%E4%BB%8B%E7%BB%8D.html"/>
      <url>/HDFS%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7%E4%BB%8B%E7%BB%8D.html</url>
      <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在hadoop2.0.0之前，HDFS集群中存在NameNode单点故障的问题，只要集群中一个NameNode不可用时，整个cluster将不可用，直到nameNode被重启或者或者备份到了另一个独立的机器.造成问题的原因可能是：</p><ol><li>NameNode所在机器突然宕机，集群将陷入瘫痪，直到NameNode服务重启</li><li>NameNode所在机器软硬件升级，将会导致集群在期间无法提供服务</li></ol><p>&nbsp;&nbsp;&nbsp;&nbsp; HDFS HA的实现方式是在每个HDFS集群中运行两个NameNode（or more），他们以主/从模式运行，activeNode负责接收客户端的读写操作，将操作保存在JNS集群中，从节点会不断地读取JNS集群中的操作信息，从而实现主从NameNode数据同步，当主Node节点不可用时，把从节点切换为主节点。</p><h3><span id="ha-架构设计">HA 架构设计</span></h3><p>&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;在典型的HA架构中，two or more独立的机器被配置为Namenode，任何时刻，只有一个Namenode处于Active状态，其他都处于standby状态；Active Namenode负责接收Client端请求，Standy节点作为备胎并没资格和客户端交互，它只是不停地备份数据，努力与ActiveNode保持一致，争取在主机点挂掉后切换为主节点。</p><p>&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;为了让Standby Node与Active Node保持同步，这两个Node都与一组称为JNS的独立的进程通信(Journal Nodes)。当Active Node接受客户端请求修改了namespace，它将把修改log写入到到JNS集群的大多数节点。Standby noes会不断地监控JNS集群上edit log的改变。当Standby Node看到写入完成的edit log后，会将log同步到自己的namespace中。这样在主从节点切换时，Standby可以确保已经从从JNS中读取到了activeNode记录的所有edits。为了支持快速切换，Standby node必须持有集群中所有block的最新位置。为此，所有Datanode都配置了Namenodes的地址（主从都配置），并把block位置上报给它们。    </p><p>&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;任何时刻，集群中只能有一个Active Namenode为客户端提供服务，否则会造成数据丢失或者结果不一致，这是灾难性的。比如当oldActiveNode宕机后，有newActiveNode被提拔为主节点，当oldActiveNode醒悟时，可能因网络延时等原因认为自己任然是主节点并继续提供服务，这就造成了我们成为双主或脑裂（）的行为。HDFS的应对措施是：JNS永远只允许一个Namenode作为writer；在failover期间，只有被选中为未来主节点（唯一）的Standby Node可以代替oldActiveNode的职责，向JNS写入log，这就阻止了其他Namenode基于处于Active状态的问题。此外主从节点namespaces快速同步是必须的，否则主节点挂掉后会因为同步时间长而有很长的空窗期集群瘫痪。</p><h3><span id="高可用性实现">高可用性实现</span></h3><p>&nbsp;&nbsp;&nbsp;&nbsp; HDFS的HA实现主要包括两部分：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://www.boren33.com/NameNode主备切换.html">NameNode主从切换</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="">NameNode数据同步</a></p><p>&nbsp;&nbsp;&nbsp;&nbsp; 本文翻译自<a href="http://hadoop.apache.org/docs/r3.1.1/hadoop-project-dist/hadoop-hdfs/HDFSHighAvailabilityWithQJM.html" target="_blank" rel="noopener">http://hadoop.apache.org/docs/r3.1.1/hadoop-project-dist/hadoop-hdfs/HDFSHighAvailabilityWithQJM.html</a></p>]]></content>
      
      <categories>
          
          <category> 技术人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hadoop </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>NameNode主备切换</title>
      <link href="/NameNode%E4%B8%BB%E5%A4%87%E5%88%87%E6%8D%A2.html"/>
      <url>/NameNode%E4%B8%BB%E5%A4%87%E5%88%87%E6%8D%A2.html</url>
      <content type="html"><![CDATA[<p>​        主备切换控制器 (ZKFailoverController )作为独立的进程运行，与HealthMonitor 、ActiveStandbyElector两大组件一起对 NameNode 的主备切换进行控制。它启动时，会初始化ActiveStandyElector和healthMonitor,并将回调函数注册进去，当healthMonitor检测到节点状态变化时，利用回调方法通知ZKFailoverController，然后ZKFailoverController使用ActiveStandyElector发起主从选举，当选举结果出来时，ActiveStandyElector将使用注册进去的回调方法通知ZKFailoverController，ZKFailoverController将其转化为Active/Standy Node。</p><h2><span id="healthmonitor介绍">HealthMonitor介绍</span></h2><p>​         主备切换控制器（ZKFailoverController ）在初始化时会创建 HealthMonitor，HealthMonitor 在内部会启动一个线程来循环调用 NameNode 的 HAServiceProtocol RPC 接口的方法来检测 NameNode 的状态，并将状态的变化通过回调的方式来通知 ZKFailoverController。HealthMonitor类包含一个内部类MonitorDaemon,MonitorDaemon是一个守护进程程序，会随着系统一起启动，在系统运行期间循环、周期地向HA SERVICE发送心跳包，与服务保持联系，当服务的健康状况发生改变时，通知failover controller。HealthMonitor主要检测 NameNode 的两类状态，分别是 HealthMonitor.State 和 HAServiceStatus（如下所述）.                                                                                                                                                                                                                          </p><p>HealthMonitor包括以下内容</p><ol><li>MonitorDaemon 守护进程程序，会在HealthMonitor启动时start，在与HA-service连接成功前一直循环，随后检查并并监听服务的健康状况，当服务的健康状况发生改变时，通知failover controller，以上是通过HAServiceProtocol实现的。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (shouldRun) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123; </span><br><span class="line">      loopUntilConnected();</span><br><span class="line">      doHealthChecks();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">      Preconditions.checkState(!shouldRun,</span><br><span class="line">          <span class="string">"Interrupted but still supposed to run"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>HAServiceProtocol 扮演代理角色，负责与HA-service连接，检查健康</li><li>HAServiceTarget 被监控的service</li><li>HealthMonitor.State   service的健康状态，有以下几种</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">INITIALIZING (<span class="string">"检查器正在初始化"</span>)</span><br><span class="line">SERVICE_NOT_RESPONDING (<span class="string">"service没有回应，没有成功connect"</span>) </span><br><span class="line">SERVICE_HEALTHY(<span class="string">"与service成功连接且健康"</span>),</span><br><span class="line">SERVICE_UNHEALTHY(<span class="string">"成功连接但不健康"</span>)</span><br><span class="line">HEALTH_MONITOR_FAILED (<span class="string">"检查器本身故障，无法继续检查"</span>)</span><br></pre></td></tr></table></figure><ol start="5"><li>callback 当HealthMonitor.State发生变化时，执行回调方法，通知ZKFailoverController做相关处理</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">enterState</span><span class="params">(State newState)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (newState != state) &#123;</span><br><span class="line">    LOG.info(<span class="string">"Entering state &#123;&#125;"</span>, newState);</span><br><span class="line">    state = newState;</span><br><span class="line">    <span class="keyword">synchronized</span> (callbacks) &#123;</span><br><span class="line">      <span class="keyword">for</span> (Callback cb : callbacks) &#123;</span><br><span class="line">        cb.enteredState(newState);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li>ServiceStateCallback 当检查到service的HAServiceStatus发生变化时，通知ZKFailoverController，HAServiceStatus反应了HA状态，具体如下</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">INITIALIZING(<span class="string">"initializing"</span>),</span><br><span class="line">ACTIVE(<span class="string">"active"</span>),</span><br><span class="line">STANDBY(<span class="string">"standby"</span>),</span><br><span class="line">STOPPING(<span class="string">"stopping"</span>);</span><br></pre></td></tr></table></figure><p><strong>以下是HealthMonitor的调用过程，当控制器将callback回调控制器的方法后，控制器将通过主从选举器进行选举</strong></p><h2><span id="activestandbyelector">ActiveStandbyElector</span></h2><p>​        ActiveStandbyElector借助zookeeper的写一致性和临时节点机制来实现leader选举，最终只有一个实例能够成功创建临时节点，这个实例对应的namenode将成为leader，其他的成为从节点。当选取出结果时，ActiveStandbyElector 会回调 ZKFailoverController 的方法，然后ZKFailoverController将对应的 NameNode 切换为active/ Standby 状态。</p><h3><span id="activestandbyelector初始化">ActiveStandbyElector初始化</span></h3><p>创建一个ActiveStandbyElector对象，会创建与zk的连接并注册watcher监听，WatcherWithClientRef watcher，调用watcher的waitForZKConnectionEvent（）来监控事件（主要关注connection and node event）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ActiveStandbyElector</span><span class="params">(String zookeeperHostPorts,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">int</span> zookeeperSessionTimeout, String parentZnodeName, List&lt;ACL&gt; acl,</span></span></span><br><span class="line"><span class="function"><span class="params">      List&lt;ZKAuthInfo&gt; authInfo, ActiveStandbyElectorCallback app,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">int</span> maxRetryNum)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> ZooKeeper <span class="title">connectToZooKeeper</span><span class="params">()</span> <span class="keyword">throws</span> IOException,</span></span><br><span class="line"><span class="function">      KeeperException </span>&#123;</span><br><span class="line">    watcher = <span class="keyword">new</span> WatcherWithClientRef();</span><br><span class="line">    ZooKeeper zk = createZooKeeper();</span><br><span class="line">    watcher.setZooKeeperRef(zk);</span><br><span class="line">    watcher.waitForZKConnectionEvent(zkSessionTimeout);</span><br><span class="line">    <span class="keyword">for</span> (ZKAuthInfo auth : zkAuthInfo) &#123;</span><br><span class="line">      zk.addAuthInfo(auth.getScheme(), auth.getAuth());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> zk;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3><span id="创建锁节点and主从选举">创建锁节点and主从选举</span></h3><p>​      当HealthMonitor检测到对应的NameNode的状态正常，那么表示这个NameNode有资格参加Zookeeper的主备选举。如果目前还没有进行过主备选举的话，那么相应的ActiveStandbyElector就会发起一次主备选举，尝试在Zookeeper上创建一个路径为/hadoop-ha/${dfs.nameservices}/ActiveStandbyElectorLock的临时节点，Zookeeper的写一致性会保证最终只会有一个ActiveStandbyElector创建成功，成功创建的ActiveStandbyElector对应的NameNode就会被选举为主节点，然后ActiveStandbyElector会回调ZKFailoverController的方法，ZKFailoverController将对应的NameNode切换为Active状态。如果ZKFailoverController切换状态失败，会转为从节点并重新加入选举；而创建失败的 ActiveStandbyElector对应的NameNode被选举为备NameNode，ActiveStandbyElector会回调ZKFailoverController的方法进一步将对应的NameNode切换为Standby状态。无论最终切换为什么节点，都会继续监控activeNameNode。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//interface implementation of Zookeeper callback for create</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">if</span> (LOG.isDebugEnabled()) &#123;</span><br><span class="line">  LOG.debug(<span class="string">"CreateNode result: "</span> + rc + <span class="string">" for path: "</span> + path</span><br><span class="line">      + <span class="string">" connectionState: "</span> + zkConnectionState +</span><br><span class="line">      <span class="string">"  for "</span> + <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">Code code = Code.get(rc);</span><br><span class="line"><span class="keyword">if</span> (isSuccess(code)) &#123;</span><br><span class="line">  <span class="comment">// we successfully created the znode. we are the leader. start monitoring</span></span><br><span class="line">  <span class="keyword">if</span> (becomeActive()) &#123;</span><br><span class="line">    monitorActiveStatus();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    reJoinElectionAfterFailureToBecomeActive();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isNodeExists(code)) &#123;</span><br><span class="line">  <span class="keyword">if</span> (createRetryCount == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// znode exists and we did not retry the operation. so a different</span></span><br><span class="line">    <span class="comment">// instance has created it. become standby and monitor lock.</span></span><br><span class="line">    becomeStandby();</span><br><span class="line">  &#125;</span><br><span class="line">  monitorActiveStatus();</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="watcher监听nodedelete事件">watcher监听NodeDELETE事件</span></h3><p>当active nameNode所在机器发生故障时，临时节点将被删掉。此时watcher将会处理事件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">  hasReceivedEvent.countDown();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!hasSetZooKeeper.await(zkSessionTimeout, TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">      LOG.debug(<span class="string">"Event received with stale zk"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ActiveStandbyElector.<span class="keyword">this</span>.processWatchEvent(</span><br><span class="line">        zk, event);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">    fatalError(</span><br><span class="line">        <span class="string">"Failed to process watcher event "</span> + event + <span class="string">": "</span> +</span><br><span class="line">        StringUtils.stringifyException(t));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当监听到connection和node 事件时，watcher会执行一些操作，这里只讨论NodeDeleted，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * interface implementation of Zookeeper watch events (connection and node),</span></span><br><span class="line"><span class="comment">   * proxied by &#123;<span class="doctag">@link</span> WatcherWithClientRef&#125;.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">String path = event.getPath();</span><br><span class="line">    <span class="keyword">if</span> (path != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">switch</span> (eventType) &#123;</span><br><span class="line">      <span class="keyword">case</span> NodeDeleted:</span><br><span class="line">        <span class="keyword">if</span> (state == State.ACTIVE) &#123;</span><br><span class="line">          enterNeutralMode();</span><br><span class="line">        &#125;</span><br><span class="line">        joinElectionInternal();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> NodeDataChanged:</span><br><span class="line">        monitorActiveStatus();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">if</span> (LOG.isDebugEnabled()) &#123;</span><br><span class="line">          LOG.debug(<span class="string">"Unexpected node event: "</span> + eventType + <span class="string">" for path: "</span> + path);</span><br><span class="line">        &#125;</span><br><span class="line">        monitorActiveStatus();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br></pre></td></tr></table></figure><h3><span id="脑裂问题">脑裂问题</span></h3><p>如果 Zookeeper 客户端机器overload，可能会导致 Zookeeper client到 Zookeeper server的心跳包不能正常发出，一旦这个时间超过了 Zookeeper Session Timeout，Zookeeper server就会认为client的 session 已经过期，将客户端的 Session 关闭从而引起脑裂 (brain-split) 现象。</p><p>当发生脑裂时，activeNode的临时节点会被删除，从而唤醒其他服务进行选举，产生新的activeNode。但此时oldNode 可能仍然处于 Active 状态正常运行。对应的 ZKFailoverController 负载下降而恢复正常后，虽然知到自己和 Zookeeper 的 Session 已经关闭，但是由于网络延迟以及 CPU 线程调度的不确定性，仍然有可能会在接下来的一段时间窗口内认为自己还是处于 Active 状态，这样oldActiveNode和 newActiveNode都处于 Active 状态，都可以对外提供服务。这种情况对于 NameNode 这类对数据一致性要求非常高的系统来说是灾难性的，数据会发生错乱且无法恢复。Zookeeper 社区的应对方案是 fencing(隔离)：把旧的 Active NameNode 隔离，使之不能正常对外提供服务。</p><p><strong>ActiveStandbyElector会在选举为主节点时，创建一个持久节点/hadoop-ha/${dfs.nameservices}/ActiveBreadCrumb，这个节点里面保存了这个 Active NameNode 的地址信息</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在选举为主节点时，会创建一个持久节点</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">becomeActive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">assert</span> wantToBeInElection;</span><br><span class="line">  <span class="keyword">if</span> (state == State.ACTIVE) &#123;</span><br><span class="line">    <span class="comment">// already active</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    Stat oldBreadcrumbStat = fenceOldActive();<span class="comment">//回调方法，返回old active node</span></span><br><span class="line">    writeBreadCrumbNode(oldBreadcrumbStat);</span><br><span class="line">    LOG.debug(<span class="string">"Becoming active for &#123;&#125;"</span>, <span class="keyword">this</span>);</span><br><span class="line">    appClient.becomeActive();</span><br><span class="line">    state = State.ACTIVE;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    LOG.warn(<span class="string">"Exception handling the winning of election"</span>, e);</span><br><span class="line">    <span class="comment">// Caller will handle quitting and rejoining the election.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果 breadcrumb node 存在，表明有oldActiveNode需要隔离, 调用ZKFailoverController的方法去隔离,返回stat(非null)，如果breadcrumb node不存在，返回null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Stat <span class="title">fenceOldActive</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, KeeperException </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Stat stat = <span class="keyword">new</span> Stat();</span><br><span class="line">  <span class="keyword">byte</span>[] data;</span><br><span class="line">  LOG.info(<span class="string">"Checking for any old active which needs to be fenced..."</span>);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    data = zkDoWithRetries(<span class="keyword">new</span> ZKAction&lt;<span class="keyword">byte</span>[]&gt;() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">byte</span>[] run() <span class="keyword">throws</span> KeeperException, InterruptedException &#123;</span><br><span class="line">        <span class="keyword">return</span> zkClient.getData(zkBreadCrumbPath, <span class="keyword">false</span>, stat);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (KeeperException ke) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isNodeDoesNotExist(ke.code())) &#123;</span><br><span class="line">      LOG.info(<span class="string">"No old node to fence"</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// If we failed to read for any other reason, then likely we lost</span></span><br><span class="line">    <span class="comment">// our session, or we don't have permissions, etc. In any case,</span></span><br><span class="line">    <span class="comment">// we probably shouldn't become active, and failing the whole</span></span><br><span class="line">    <span class="comment">// thing is the best bet.</span></span><br><span class="line">    <span class="keyword">throw</span> ke;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  LOG.info(<span class="string">"Old node exists: &#123;&#125;"</span>, StringUtils.byteToHexString(data));</span><br><span class="line">  <span class="keyword">if</span> (Arrays.equals(data, appData)) &#123;</span><br><span class="line">    LOG.info(<span class="string">"But old node has our own data, so don't need to fence it."</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    appClient.fenceOldActive(data);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> stat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果old activeNode不存在，创建持久节点；否则更新node</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeBreadCrumbNode</span><span class="params">(Stat oldBreadcrumbStat)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> KeeperException, InterruptedException </span>&#123;</span><br><span class="line">  Preconditions.checkState(appData != <span class="keyword">null</span>, <span class="string">"no appdata"</span>);</span><br><span class="line">  </span><br><span class="line">  LOG.info(<span class="string">"Writing znode &#123;&#125; to indicate that the local "</span> +</span><br><span class="line">      <span class="string">"node is the most recent active..."</span>, zkBreadCrumbPath);</span><br><span class="line">  <span class="keyword">if</span> (oldBreadcrumbStat == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// No previous active, just create the node</span></span><br><span class="line">    createWithRetries(zkBreadCrumbPath, appData, zkAcl,</span><br><span class="line">      CreateMode.PERSISTENT);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    setDataWithRetries(zkBreadCrumbPath, appData, oldBreadcrumbStat.getVersion());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        </p><h2><span id="zkfailovercontroller介绍">ZKFailoverController介绍</span></h2><p>​        主备切换控制器 (ZKFailoverController )作为独立的进程运行，与HealthMonitor 、ActiveStandbyElector两大组件一起对 NameNode 的主备切换进行控制。它启动时，会初始化ActiveStandyElector和healthMonitor,并将回调函数注册进去，当healthMonitor检测到节点状态变化时，利用回调方法通知ZKFailoverController，然后ZKFailoverController使用ActiveStandyElector发起主从选举，当选举结果出来时，ActiveStandyElector将使用注册进去的回调方法通知ZKFailoverController，ZKFailoverController将其转化为Active/Standy Node。</p><ol><li>ZKFailoverController的初始化时会initZK，构造ActiveStandyElector</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initZK</span><span class="params">()</span> <span class="keyword">throws</span> HadoopIllegalArgumentException, IOException,</span></span><br><span class="line"><span class="function">    KeeperException </span>&#123;</span><br><span class="line">  zkQuorum = conf.get(ZK_QUORUM_KEY);</span><br><span class="line">  <span class="keyword">int</span> zkTimeout = conf.getInt(ZK_SESSION_TIMEOUT_KEY,</span><br><span class="line">      ZK_SESSION_TIMEOUT_DEFAULT);</span><br><span class="line">  <span class="comment">// Parse ACLs from configuration.</span></span><br><span class="line">  String zkAclConf = conf.get(ZK_ACL_KEY, ZK_ACL_DEFAULT);</span><br><span class="line">  zkAclConf = ZKUtil.resolveConfIndirection(zkAclConf);</span><br><span class="line">  List&lt;ACL&gt; zkAcls = ZKUtil.parseACLs(zkAclConf);</span><br><span class="line">  <span class="keyword">if</span> (zkAcls.isEmpty()) &#123;</span><br><span class="line">    zkAcls = Ids.CREATOR_ALL_ACL;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Parse authentication from configuration.</span></span><br><span class="line">  List&lt;ZKAuthInfo&gt; zkAuths = SecurityUtil.getZKAuthInfos(conf, ZK_AUTH_KEY);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Sanity check configuration.</span></span><br><span class="line">  Preconditions.checkArgument(zkQuorum != <span class="keyword">null</span>,</span><br><span class="line">      <span class="string">"Missing required configuration '%s' for ZooKeeper quorum"</span>,</span><br><span class="line">      ZK_QUORUM_KEY);</span><br><span class="line">  Preconditions.checkArgument(zkTimeout &gt; <span class="number">0</span>,</span><br><span class="line">      <span class="string">"In</span></span><br><span class="line"><span class="string">  int maxRetryNum = conf.getInt(</span></span><br><span class="line"><span class="string">      CommonConfigurationKeys.HA_FC_ELECTOR_ZK_OP_RETRIES_KEY,</span></span><br><span class="line"><span class="string">      CommonConfigurationKeys.HA_FC_ELECTOR_ZK_OP_RETRIES_DEFAULT);</span></span><br><span class="line"><span class="string">  elector = new ActiveStandbyElector(zkQuorum,</span></span><br><span class="line"><span class="string">      zkTimeout, getParentZnode(), zkAcls, zkAuths,</span></span><br><span class="line"><span class="string">      new ElectorCallbacks(), maxRetryNum);</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>​    <strong>initZK时创建了ActiveStandyElector，并将回调类注册进去，方便ActiveStandyElector监听</strong>，</p><ol><li>ZKFailoverController的初始化时，会initHealthMonitor</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initHM</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  healthMonitor = <span class="keyword">new</span> HealthMonitor(conf, localTarget);</span><br><span class="line">  healthMonitor.addCallback(<span class="keyword">new</span> HealthCallbacks());</span><br><span class="line">  healthMonitor.addServiceStateCallback(<span class="keyword">new</span> ServiceStateCallBacks());</span><br><span class="line">  healthMonitor.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>initHM时，将回调对象注册进去，当HM监听到状态变化时，利用回调函数通知控制器</li><li>当HM执行回调方法enterState（newState）时，控制器使用主从选择器让该节点进入/退出选举</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Callbacks from HealthMonitor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HealthCallbacks</span> <span class="keyword">implements</span> <span class="title">HealthMonitor</span>.<span class="title">Callback</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enteredState</span><span class="params">(HealthMonitor.State newState)</span> </span>&#123;</span><br><span class="line">    setLastHealthState(newState);</span><br><span class="line">    recheckElectability();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Check the current state of the service, and join the election</span></span><br><span class="line"><span class="comment">   * if it should be in the election.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">recheckElectability</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Maintain lock ordering of elector -&gt; ZKFC</span></span><br><span class="line">    <span class="keyword">synchronized</span> (elector) &#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> healthy = lastHealthState == State.SERVICE_HEALTHY;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">long</span> remainingDelay = delayJoiningUntilNanotime - System.nanoTime(); </span><br><span class="line">        <span class="keyword">if</span> (remainingDelay &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (healthy) &#123;</span><br><span class="line">            LOG.info(<span class="string">"Would have joined master election, but this node is "</span> +</span><br><span class="line">                <span class="string">"prohibited from doing so for "</span> +</span><br><span class="line">                TimeUnit.NANOSECONDS.toMillis(remainingDelay) + <span class="string">" more ms"</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          scheduleRecheck(remainingDelay);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">switch</span> (lastHealthState) &#123;</span><br><span class="line">        <span class="keyword">case</span> SERVICE_HEALTHY:</span><br><span class="line">          elector.joinElection(targetToData(localTarget));</span><br><span class="line">          <span class="keyword">if</span> (quitElectionOnBadState) &#123;</span><br><span class="line">            quitElectionOnBadState = <span class="keyword">false</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">          </span><br><span class="line">        <span class="keyword">case</span> INITIALIZING:</span><br><span class="line">          LOG.info(<span class="string">"Ensuring that "</span> + localTarget + <span class="string">" does not "</span> +</span><br><span class="line">              <span class="string">"participate in active master election"</span>);</span><br><span class="line">          elector.quitElection(<span class="keyword">false</span>);</span><br><span class="line">          serviceState = HAServiceState.INITIALIZING;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">case</span> SERVICE_UNHEALTHY:</span><br><span class="line">        <span class="keyword">case</span> SERVICE_NOT_RESPONDING:</span><br><span class="line">          LOG.info(<span class="string">"Quitting master election for "</span> + localTarget +</span><br><span class="line">              <span class="string">" and marking that fencing is necessary"</span>);</span><br><span class="line">          elector.quitElection(<span class="keyword">true</span>);</span><br><span class="line">          serviceState = HAServiceState.INITIALIZING;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">          </span><br><span class="line">        <span class="keyword">case</span> HEALTH_MONITOR_FAILED:</span><br><span class="line">          fatalError(<span class="string">"Health monitor failed!"</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">          </span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unhandled state:"</span></span><br><span class="line">                                               + lastHealthState);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>选举器在选举结束后，会在processXXX（）回调控制器的方法，通知控制器选举完成，然后控制器通过HAServiceProtocol的rpc调用将对应的节点变为主/从节点</p><h3><span id="总结">总结</span></h3><p><img src="https://www.ibm.com/developerworks/cn/opensource/os-cn-hadoop-name-node/img002.png" alt="NameNode主从切换的过程"></p><p>​                                    <a href="http://www.boren33.com/2018/08/22/NameNode%E4%B8%BB%E5%A4%87%E5%88%87%E6%8D%A2/">图片引自</a></p><h3><span id="注意事项">注意事项</span></h3><p>**最后需要注意的是这个选举机制只有当候选节点较少时才有效（order of 10’s），因为大量候选者连接zookeeper的同一个节点会导致zookeeper过载。</p>]]></content>
      
      <categories>
          
          <category> 技术人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hadoop </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>新梦想</title>
      <link href="/%E6%96%B0%E6%A2%A6%E6%83%B3.html"/>
      <url>/%E6%96%B0%E6%A2%A6%E6%83%B3.html</url>
      <content type="html"><![CDATA[<p>2018刚好过半，敬往事一杯酒，致新梦想以微笑。</p><p>新时代，新梦想，愿你在未来的每一天，不因过去而悔恨，只因今天而骄傲，加油。</p>]]></content>
      
      <categories>
          
          <category> 往事随风 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>简聊JAVA NIO</title>
      <link href="/%E7%AE%80%E8%81%8AJAVA-NIO.html"/>
      <url>/%E7%AE%80%E8%81%8AJAVA-NIO.html</url>
      <content type="html"><![CDATA[<p>java NIO（non blocking IO），是一种同步非阻塞IO，为IO多路复用的基础，适用于高并发与大量连接，主要由三大组件构成：channel、Buffer、Selector，虽然还有一些其他组件，如管道，但大多是基于这三大组件而构造的。</p><h1><span id="channel">channel</span></h1><p>  与java BIO 数据流单向传输不同的是，NIO中引入了channel，它可以双向传输，既可以将数据通过缓冲写入到channel中，也可以将channel中的数据读入缓存。常见的channel类型有</p><p>  FileChannel（阻塞，无法结合selector使用）<br>  DatagramChannel<br>  SocketChannel<br>  ServerSocketChannel</p><h1><span id="buffer">Buffer</span></h1><p>   缓冲Buffer容易理解，就是把读取到的数据放入一个或多个池中，等池子满了，可以一次拿走；或者将数据分别放到不同的池中，一次性传输到channel中。而不必多次运输。<br>   Buffer中有四个属性：mark、capacity、position、limit。</p><p>  <img src="/images/buffer.png" alt="buffer原理"></p><h3><span id="mark">mark</span></h3><p>初始值为-1，用于备份当前的position  </p><h3><span id="capacity">capacity</span></h3><p>capacity代表缓冲池的大小，当缓冲池满了，需要将其清空（通过读数据或者清除数据）才能继续往里写数据。</p><h3><span id="position">position</span></h3><p>position表示当前读/写的位置。<br>写模式中，position初始为0，当往缓冲池写入一个byte、long等数据时，postion会移到下一个可写的位置。<br>从写模式切换到读模式时，position重置为0，每读取一个数据，position会向前移动到下一个可读的位置</p><h3><span id="limit">limit</span></h3><p>在写模式下，Buffer的limit表示你最多能往Buffer里写多少数据（等于capacity）。当切换Buffer到读模式时，limit表示你最多能读到多少数据。因此，当切换Buffer到读模式时，limit会被设置成写模式下的position值。即之前写入的所有数据。</p><h2><span id="方法">方法</span></h2><p>mark()：把当前的position赋值给mark<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">mark</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mark = position;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>reset()：把mark值还原给position<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = mark;</span><br><span class="line">    <span class="keyword">if</span> (m &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InvalidMarkException();</span><br><span class="line">    position = m;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>clear()：一旦读完Buffer中的数据，需要让Buffer准备好再次被写入，clear会恢复状态值，但不会擦除数据。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    position = <span class="number">0</span>;</span><br><span class="line">    limit = capacity;</span><br><span class="line">    mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>flip()：Buffer有两种模式，写模式和读模式，flip后Buffer从写模式变成读模式。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">flip</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    limit = position;</span><br><span class="line">    position = <span class="number">0</span>;</span><br><span class="line">    mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>rewind()：重置position为0，从头读写数据。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">rewind</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    position = <span class="number">0</span>;</span><br><span class="line">    mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2><span id="分散聚集-scattergather">分散/聚集 Scatter/Gather</span></h2><p>Scatter（分散）：将一个channel的数据分散到多个缓存池中；<br>Gather：将多个缓冲池中的数据写入一个channel。<br>前者在将数据写入到下一个缓冲池前必须先将第一个池子填满，，而后者只能将position和limit之间的数据写入channel。因此前者不适合将大小不固定的消息读入多个缓冲池中，如消息体和消息消息头。后者适合写入灵活大小的消息，如把数据分为两部分，分别存放在headerBuffer和bodyBuffer中。</p><h1><span id="selector">selector</span></h1><p>想象一个场景：一个酒店服务员，负责好几个房间，每个房间住房、退房，她都会登记，这样当我们想知道某个房间的入住情况时，直接问这个服务员就好；<br>在selector模型中，每个channel相当于一个房间，selector相当于上述的服务员，线程可以通过一个selector监听多个channel的状态，在每个channel有相关事件就绪时，返回函数。需要知道的是</p><ol><li>selector是非阻塞的，所以阻塞channel（FileChannel）无法与他搭配使用。</li><li>需要让selector管理的channel必须先注册<br>   channel.register(selector,interstOps);<br>第二个参数代表selector对channel的什么事情感兴趣</li><li>要知道是否有channel事件就休可以调用select方法;返回值<br> 表示多少个channel事件就绪：<br> select()一直阻塞，直到事件就绪<br> select（long time），规定时间内channel没有事件就绪，直接返回0，<br>  seectNow()不会阻塞，不管什么通道就绪都立刻返回.</li><li><p>在select方法返回数据后，可以通过 selectedKeys()查看事件详情，SelectionKey结构如下：</p><ul><li><p>SelectionKey中定义了四个常量来表示事件</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">OP_READ = <span class="number">1</span> &lt;&lt; <span class="number">0</span>;</span><br><span class="line">OP_WRITE = <span class="number">1</span> &lt;&lt; <span class="number">2</span>;</span><br><span class="line">OP_CONNECT = <span class="number">1</span> &lt;&lt; <span class="number">3</span>;</span><br><span class="line">OP_ACCEPT = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br></pre></td></tr></table></figure></li><li><p>感兴趣的事件的集（或运算计算得a|b|c）             </p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> SelectionKey <span class="title">interestOps</span><span class="params">(<span class="keyword">int</span> ops)</span></span>;<span class="comment">//</span></span><br></pre></td></tr></table></figure></li><li><p>已就绪的事件，可能多个，这样我们就可以判断当前channel是否可读/写/连接等</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">readyOps</span><span class="params">()</span></span>;</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isReadable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (readyOps() &amp; OP_READ) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isWritable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (readyOps() &amp; OP_WRITE) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h1><span id="实例">实例</span></h1><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Selector selector = Selector.open();</span><br><span class="line">channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">SelectionKey key = channel.register(selector, SelectionKey.OP_READ);</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">  <span class="keyword">int</span> readyChannels = selector.select();</span><br><span class="line">  <span class="keyword">if</span>(readyChannels == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">  Set selectedKeys = selector.selectedKeys();</span><br><span class="line">  Iterator keyIterator = selectedKeys.iterator();</span><br><span class="line">  <span class="keyword">while</span>(keyIterator.hasNext()) &#123;</span><br><span class="line">    SelectionKey key = keyIterator.next();</span><br><span class="line">    <span class="keyword">if</span>(key.isAcceptable()) &#123;</span><br><span class="line">        <span class="comment">// a connection was accepted by a ServerSocketChannel.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isConnectable()) &#123;</span><br><span class="line">        <span class="comment">// a connection was established with a remote server.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">        <span class="comment">// a channel is ready for reading</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isWritable()) &#123;</span><br><span class="line">        <span class="comment">// a channel is ready for writing</span></span><br><span class="line">    &#125;</span><br><span class="line">    keyIterator.remove();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><h1><span id="nio-优缺点">NIO 优缺点</span></h1><ul><li>单线程可以处理多任务，多线程可以处理更多的连接，节省了线程开支</li><li>socket主要的读、写、注册和接收函数，在等待就绪阶段都是非阻塞的，只有在I/O操作时是同步阻塞的（消耗CPU但性能非常高）</li><li>基于block的传输，通常比基于流的传输更高效</li><li><p>IO多路复用大大提高了Java网络应用的可伸缩性和实用性</p></li><li><p>并发程度不高或者局域网环境下NIO并没有显著的性能优势。</p></li><li>NIO没有完全屏蔽平台差异，各平台的实现存在差异。使用NIO做网络编程构建事件驱动模型并不容易。</li></ul><p>参考资料 <a href="http://tutorials.jenkov.com/java-nio/overview.html" target="_blank" rel="noopener">http://tutorials.jenkov.com/java-nio/overview.html</a></p>]]></content>
      
      <categories>
          
          <category> 技术人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IO </tag>
            
            <tag> NIO </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>给过去的一封信</title>
      <link href="/%E7%BB%99%E8%BF%87%E5%8E%BB%E7%9A%84%E4%B8%80%E5%B0%81%E4%BF%A1.html"/>
      <url>/%E7%BB%99%E8%BF%87%E5%8E%BB%E7%9A%84%E4%B8%80%E5%B0%81%E4%BF%A1.html</url>
      <content type="html"><![CDATA[<h2><span id="引言">引言</span></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>痛苦要么成就一个人,要么彻底摧毁他!</strong></p><h2><span id="忧伤的过去">忧伤的过去</span></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;世界上最痛苦的事从不是我无法做到,而是我本可以…人们容易陷入过往的悔恨中,理由太多了,比如儿时的不懂事,为现在未来埋下祸根,亦是回眸之间,错过最重要的人,或者是包括过去的不努力,这些往往是相辅相成,不可分割,共同组成你的心魔.</p><h2><span id="为什么要放下过去">为什么要放下过去?</span></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;曾经我问世界:命运是什么?它告诉我:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个人的命运不只是指他的天赋和出身，还包括那些”早年的经历”。在思想不成熟的时期，我们有可能无意识地犯下大错，从此影响了一生！这些都是不可控的。它叫作命运！命运无需在意，就像童年犯错一样。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而当我们真正明白并接受自己的过去后，我们就长大了，剩下的人生就不存在命运之说，此时的生活是事在人为，我们只需大胆追求想要得一切!<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对,在你走出来之前,你那些看似愚蠢的错误确实是一种命,当你想明白后,过去的你随过往时光都烟消云散,既然当初的自己随着过往都死了,那又与你何干</p><h2><span id="如何放下过去">如何放下过去.</span></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>别想一下就改变</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>别想没用的</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>别让自己的惯性思维害了自己</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;人总是在痛苦中不断成长,期间可能是无限循环的,直到一个时刻,这个条件被打破.这几天回顾了下过去的生活,发现自己始终没有真正走出来,亦无法全心全意的工作,这也困扰了我太多,越是这样越是愤恨自己,zui’hou发现了这么一个规矩:</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>一直做(想)一件事非常容易,但想打破这个状态时会异常难,这叫惯性.</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么是不是无法改变呢?当然不是,当我们开始一件新事物时,脑海中会有各种杂念,但是如果你足够意志坚定,这种抵触思维会慢慢消退.第一次可能痛苦好几天,第二次痛苦一两天,第三天几个小时,再到最后每次持续几分钟甚至几秒.到了后期,你会发现你战胜了过去的自己.一切似乎不可思议.长此以往,你就变得不再是当初的自己</p>]]></content>
      
      <categories>
          
          <category> 往事随风 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>遇见美丽</title>
      <link href="/%E9%81%87%E8%A7%81%E7%BE%8E%E4%B8%BD.html"/>
      <url>/%E9%81%87%E8%A7%81%E7%BE%8E%E4%B8%BD.html</url>
      <content type="html"><![CDATA[<p>生活不止眼前的苟且,还有诗和远方的田野<br>你赤手空拳来到人世间,为找到那片海不顾一切<br>当我寻找光明的时候，不小心陷入黑暗<br>迷茫，痛苦，懊悔，绝望…<a id="more"></a><br>我在蓝色的天空，策马奔腾<br>懊悔，愤怒，嘶吼，战斗<br>终于找到生命的奥秘<br>我告诉自己何为理想，何为生活<br>我以为自己没有快乐,更不再有悲伤<br>我似乎失去感知所有的能力<br>直到,<br>清风徐来，我遇见你，<br>这颗沉默的心开始颤抖<br>因为过分美丽，所以无限挣扎<br>回眸瞬间，错过风雨！<br>我告诉自己<br>如果疼痛无法治愈，就用血色谱写光阴。<br>终何去何从，请听何为<a href="https://www.zhihu.com/question/265653002/answer/296655901" target="_blank" rel="noopener">命运</a></p>]]></content>
      
      <categories>
          
          <category> 往事随风 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>向左乐观,向右悲观</title>
      <link href="/%E5%90%91%E5%B7%A6%E4%B9%90%E8%A7%82,%E5%90%91%E5%8F%B3%E6%82%B2%E8%A7%82.html"/>
      <url>/%E5%90%91%E5%B7%A6%E4%B9%90%E8%A7%82,%E5%90%91%E5%8F%B3%E6%82%B2%E8%A7%82.html</url>
      <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;人生本就是马拉松,有的人历经挫折,依然潇洒,有些人从未经历,却彷徨不前.仔细观察,不过是心在作怪.而如果把一生比作函数,我们会发现一个有趣的现象:</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;掉入局部最大值的时候，人们知道这不是全局最大的，<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;掉入局部最小值时，人们总觉得这是全局最小值</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此想要快乐的活着,最关键的还是要<strong>突破思维</strong>,改变自己!</p>]]></content>
      
      <categories>
          
          <category> 往事随风 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>排序算法总结</title>
      <link href="/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.html"/>
      <url>/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.html</url>
      <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;排序,顾名思义,将数据按照某种规则排列起来.这种规则可以是根据基本的数值大小排序,也可以是通过字符串长度比较来排序,又或者是优先根据两个字符串的第一个不同值为参考来比较的排序(String的compareTo默认方法),而这个规则可以是各式各样的,你可以根据义务来自己定制排序策略,今天我们主要探讨数据结构与算法中8中基本的排序算法(全部根据数值大小比较)</p>]]></content>
      
      <categories>
          
          <category> 技术人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>人生传</title>
      <link href="/%E4%BA%BA%E7%94%9F%E4%BC%A0.html"/>
      <url>/%E4%BA%BA%E7%94%9F%E4%BC%A0.html</url>
      <content type="html"><![CDATA[<h2><span id="引言">引言</span></h2><p>  如果人生是一场炼狱,那我们何去何从<br>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;—&lt;&lt;魔也,道也&gt;&gt;</p><h2><span id="出入尘世天真无邪">出入尘世,天真无邪</span></h2><p>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;童年的我特别乖,有一次奶奶的救心丸找不到了,斥责我是不是偷去玩了,自己死活不肯承认,后来看她越来越急,就说”别找了,本少爷玩丢了”,然后就是一顿毒打….过了几天,救心丸出现在了奶奶的药盒.<br>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;小时候,村里就一个老师,同时教幼儿园到小学3年级,作为当代最小屁孩,我跟着大屁孩们一起上课,当时自己总是喜欢研究一些数学”怪题”,结局也都不错,但是特别讨厌学语文,可惜不背课文不让吃饭,于是我就特别认真的背,记得当时把几本书从头到尾背完,接着反着背,因此拿到5块钱巨款作为零花钱.</p><h2><span id="无关对错只为快乐">无关对错,只为快乐</span></h2><p>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;过去10-15年,大多数中国农村家庭十分贫穷,我家也不例外,曾经的梦想是拥有一台电脑,玩一辈子问道.还记得以前经常饿肚子,但是一玩游戏或者想象自己在玩游戏,就变得精神抖擞,这一直持续了七年,在很多人眼里这是荒废,不务正业,但它确实是一生中最纯净的时光,这就是信仰的力量吧.直到读了乔布斯传,身体的血液开始燃烧,觉得我应该改变自己,于是开始好好学习</p><h2><span id="悔恨犹在何去何从">悔恨犹在,何去何从</span></h2><p>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我的高中很不快乐,经常一个人在操场散步,或者回到教室装睡,然后沉思,时间长了,变本加厉,总是处于对过去的不满和自身的懊悔中,我从不惧怕未来,却不能接受过去,越是走不出来,浪费越多时间,时间越长,自责更深,恶性循环,此时我已从当年反应敏捷的儿童变成略有迟钝的少年.这些事情让人如此痛苦,以至于我不得不”先解决心情,再解决事情”.我找了大量心理学书,结果根本没耐心看,全理论知识,仿佛是一本本教科书.废话连篇.直到后来慢慢明白痛苦是正常的,一个人承受越大的痛苦,未来可以抗住越大的打击.,相反一个没有过痛苦和思考的人,他的一生得多普通啊?</p><h2><span id="如梦初醒大步朝前">如梦初醒,大步朝前</span></h2><p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;黑暗光明,黑暗光明,黑暗光明,惶惶中6年时间过去,已不再是当初的少年,这时更清楚自己想成为什么样的人,我开始朝着自己的梦想(兼具艺术和技术的优秀工程师)逐步努力.此时已是大二下学期.每天不去上课,沉迷于图书馆,看着妹子,刷着一道道算法题,每次accept,都触动着内心,看编译原理时,也总是惊呼原来如此,学习计网时,从一开始的认为理所当然到知其所以然都是一种兴奋,研读jdk源码时,从一开始的懵逼到初为了解,再到懵逼,再到了解..不得不感叹大佬的智慧.终于结果是美丽的,春招拿到一些互联网公司offer,最后去了小米科技(Mi fan),做push服务端开发</p><h2><span id="面朝大海春暖花开">面朝大海,春暖花开</span></h2><p>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一花一世界，一叶一如来.这个世界无所谓缺陷，即使是缺陷，也是美的.让我们朝着梦想前进</p>]]></content>
      
      <categories>
          
          <category> 往事随风 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
