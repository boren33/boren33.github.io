<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="如果批评不自由，赞美将毫无意义"><title>NameNode主备切换 | boren's blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">NameNode主备切换</h1><a id="logo" href="/.">boren's blog</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 所有文章</i></a><a href="/about/"><i class="fa fa-user"> 关于作者</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">NameNode主备切换</h1><div class="post-meta">Aug 22, 2018<span> | </span><span class="category"><a href="/categories/技术人生/">技术人生</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><div class="post-content"><p>​        主备切换控制器 (ZKFailoverController )作为独立的进程运行，与HealthMonitor 、ActiveStandbyElector两大组件一起对 NameNode 的主备切换进行控制。它启动时，会初始化ActiveStandyElector和healthMonitor,并将回调函数注册进去，当healthMonitor检测到节点状态变化时，利用回调方法通知ZKFailoverController，然后ZKFailoverController使用ActiveStandyElector发起主从选举，当选举结果出来时，ActiveStandyElector将使用注册进去的回调方法通知ZKFailoverController，ZKFailoverController将其转化为Active/Standy Node。</p>
<h2><span id="healthmonitor介绍">HealthMonitor介绍</span></h2><p>​         主备切换控制器（ZKFailoverController ）在初始化时会创建 HealthMonitor，HealthMonitor 在内部会启动一个线程来循环调用 NameNode 的 HAServiceProtocol RPC 接口的方法来检测 NameNode 的状态，并将状态的变化通过回调的方式来通知 ZKFailoverController。HealthMonitor类包含一个内部类MonitorDaemon,MonitorDaemon是一个守护进程程序，会随着系统一起启动，在系统运行期间循环、周期地向HA SERVICE发送心跳包，与服务保持联系，当服务的健康状况发生改变时，通知failover controller。HealthMonitor主要检测 NameNode 的两类状态，分别是 HealthMonitor.State 和 HAServiceStatus（如下所述）.                                                                                                                                                                                                                          </p>
<p>HealthMonitor包括以下内容</p>
<ol>
<li>MonitorDaemon 守护进程程序，会在HealthMonitor启动时start，在与HA-service连接成功前一直循环，随后检查并并监听服务的健康状况，当服务的健康状况发生改变时，通知failover controller，以上是通过HAServiceProtocol实现的。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (shouldRun) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123; </span><br><span class="line">      loopUntilConnected();</span><br><span class="line">      doHealthChecks();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">      Preconditions.checkState(!shouldRun,</span><br><span class="line">          <span class="string">"Interrupted but still supposed to run"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>HAServiceProtocol 扮演代理角色，负责与HA-service连接，检查健康</li>
<li>HAServiceTarget 被监控的service</li>
<li>HealthMonitor.State   service的健康状态，有以下几种</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">INITIALIZING (<span class="string">"检查器正在初始化"</span>)</span><br><span class="line">SERVICE_NOT_RESPONDING (<span class="string">"service没有回应，没有成功connect"</span>) </span><br><span class="line">SERVICE_HEALTHY(<span class="string">"与service成功连接且健康"</span>),</span><br><span class="line">SERVICE_UNHEALTHY(<span class="string">"成功连接但不健康"</span>)</span><br><span class="line">HEALTH_MONITOR_FAILED (<span class="string">"检查器本身故障，无法继续检查"</span>)</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>callback 当HealthMonitor.State发生变化时，执行回调方法，通知ZKFailoverController做相关处理</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">enterState</span><span class="params">(State newState)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (newState != state) &#123;</span><br><span class="line">    LOG.info(<span class="string">"Entering state &#123;&#125;"</span>, newState);</span><br><span class="line">    state = newState;</span><br><span class="line">    <span class="keyword">synchronized</span> (callbacks) &#123;</span><br><span class="line">      <span class="keyword">for</span> (Callback cb : callbacks) &#123;</span><br><span class="line">        cb.enteredState(newState);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="6">
<li>ServiceStateCallback 当检查到service的HAServiceStatus发生变化时，通知ZKFailoverController，HAServiceStatus反应了HA状态，具体如下</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">INITIALIZING(<span class="string">"initializing"</span>),</span><br><span class="line">ACTIVE(<span class="string">"active"</span>),</span><br><span class="line">STANDBY(<span class="string">"standby"</span>),</span><br><span class="line">STOPPING(<span class="string">"stopping"</span>);</span><br></pre></td></tr></table></figure>
<p><strong>以下是HealthMonitor的调用过程，当控制器将callback回调控制器的方法后，控制器将通过主从选举器进行选举</strong></p>
<h2><span id="activestandbyelector">ActiveStandbyElector</span></h2><p>​        ActiveStandbyElector借助zookeeper的写一致性和临时节点机制来实现leader选举，最终只有一个实例能够成功创建临时节点，这个实例对应的namenode将成为leader，其他的成为从节点。当选取出结果时，ActiveStandbyElector 会回调 ZKFailoverController 的方法，然后ZKFailoverController将对应的 NameNode 切换为active/ Standby 状态。</p>
<h3><span id="activestandbyelector初始化">ActiveStandbyElector初始化</span></h3><p>创建一个ActiveStandbyElector对象，会创建与zk的连接并注册watcher监听，WatcherWithClientRef watcher，调用watcher的waitForZKConnectionEvent（）来监控事件（主要关注connection and node event）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ActiveStandbyElector</span><span class="params">(String zookeeperHostPorts,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">int</span> zookeeperSessionTimeout, String parentZnodeName, List&lt;ACL&gt; acl,</span></span></span><br><span class="line"><span class="function"><span class="params">      List&lt;ZKAuthInfo&gt; authInfo, ActiveStandbyElectorCallback app,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">int</span> maxRetryNum)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> ZooKeeper <span class="title">connectToZooKeeper</span><span class="params">()</span> <span class="keyword">throws</span> IOException,</span></span><br><span class="line"><span class="function">      KeeperException </span>&#123;</span><br><span class="line">    watcher = <span class="keyword">new</span> WatcherWithClientRef();</span><br><span class="line">    ZooKeeper zk = createZooKeeper();</span><br><span class="line">    watcher.setZooKeeperRef(zk);</span><br><span class="line">    watcher.waitForZKConnectionEvent(zkSessionTimeout);</span><br><span class="line">    <span class="keyword">for</span> (ZKAuthInfo auth : zkAuthInfo) &#123;</span><br><span class="line">      zk.addAuthInfo(auth.getScheme(), auth.getAuth());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> zk;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3><span id="创建锁节点and主从选举">创建锁节点and主从选举</span></h3><p>​      当HealthMonitor检测到对应的NameNode的状态正常，那么表示这个NameNode有资格参加Zookeeper的主备选举。如果目前还没有进行过主备选举的话，那么相应的ActiveStandbyElector就会发起一次主备选举，尝试在Zookeeper上创建一个路径为/hadoop-ha/${dfs.nameservices}/ActiveStandbyElectorLock的临时节点，Zookeeper的写一致性会保证最终只会有一个ActiveStandbyElector创建成功，成功创建的ActiveStandbyElector对应的NameNode就会被选举为主节点，然后ActiveStandbyElector会回调ZKFailoverController的方法，ZKFailoverController将对应的NameNode切换为Active状态。如果ZKFailoverController切换状态失败，会转为从节点并重新加入选举；而创建失败的 ActiveStandbyElector对应的NameNode被选举为备NameNode，ActiveStandbyElector会回调ZKFailoverController的方法进一步将对应的NameNode切换为Standby状态。无论最终切换为什么节点，都会继续监控activeNameNode。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//interface implementation of Zookeeper callback for create</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">if</span> (LOG.isDebugEnabled()) &#123;</span><br><span class="line">  LOG.debug(<span class="string">"CreateNode result: "</span> + rc + <span class="string">" for path: "</span> + path</span><br><span class="line">      + <span class="string">" connectionState: "</span> + zkConnectionState +</span><br><span class="line">      <span class="string">"  for "</span> + <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">Code code = Code.get(rc);</span><br><span class="line"><span class="keyword">if</span> (isSuccess(code)) &#123;</span><br><span class="line">  <span class="comment">// we successfully created the znode. we are the leader. start monitoring</span></span><br><span class="line">  <span class="keyword">if</span> (becomeActive()) &#123;</span><br><span class="line">    monitorActiveStatus();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    reJoinElectionAfterFailureToBecomeActive();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isNodeExists(code)) &#123;</span><br><span class="line">  <span class="keyword">if</span> (createRetryCount == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// znode exists and we did not retry the operation. so a different</span></span><br><span class="line">    <span class="comment">// instance has created it. become standby and monitor lock.</span></span><br><span class="line">    becomeStandby();</span><br><span class="line">  &#125;</span><br><span class="line">  monitorActiveStatus();</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="watcher监听nodedelete事件">watcher监听NodeDELETE事件</span></h3><p>当active nameNode所在机器发生故障时，临时节点将被删掉。此时watcher将会处理事件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">  hasReceivedEvent.countDown();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!hasSetZooKeeper.await(zkSessionTimeout, TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">      LOG.debug(<span class="string">"Event received with stale zk"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ActiveStandbyElector.<span class="keyword">this</span>.processWatchEvent(</span><br><span class="line">        zk, event);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">    fatalError(</span><br><span class="line">        <span class="string">"Failed to process watcher event "</span> + event + <span class="string">": "</span> +</span><br><span class="line">        StringUtils.stringifyException(t));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当监听到connection和node 事件时，watcher会执行一些操作，这里只讨论NodeDeleted，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * interface implementation of Zookeeper watch events (connection and node),</span></span><br><span class="line"><span class="comment">   * proxied by &#123;<span class="doctag">@link</span> WatcherWithClientRef&#125;.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">String path = event.getPath();</span><br><span class="line">    <span class="keyword">if</span> (path != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">switch</span> (eventType) &#123;</span><br><span class="line">      <span class="keyword">case</span> NodeDeleted:</span><br><span class="line">        <span class="keyword">if</span> (state == State.ACTIVE) &#123;</span><br><span class="line">          enterNeutralMode();</span><br><span class="line">        &#125;</span><br><span class="line">        joinElectionInternal();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> NodeDataChanged:</span><br><span class="line">        monitorActiveStatus();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">if</span> (LOG.isDebugEnabled()) &#123;</span><br><span class="line">          LOG.debug(<span class="string">"Unexpected node event: "</span> + eventType + <span class="string">" for path: "</span> + path);</span><br><span class="line">        &#125;</span><br><span class="line">        monitorActiveStatus();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<h3><span id="脑裂问题">脑裂问题</span></h3><p>如果 Zookeeper 客户端机器overload，可能会导致 Zookeeper client到 Zookeeper server的心跳包不能正常发出，一旦这个时间超过了 Zookeeper Session Timeout，Zookeeper server就会认为client的 session 已经过期，将客户端的 Session 关闭从而引起脑裂 (brain-split) 现象。</p>
<p>当发生脑裂时，activeNode的临时节点会被删除，从而唤醒其他服务进行选举，产生新的activeNode。但此时oldNode 可能仍然处于 Active 状态正常运行。对应的 ZKFailoverController 负载下降而恢复正常后，虽然知到自己和 Zookeeper 的 Session 已经关闭，但是由于网络延迟以及 CPU 线程调度的不确定性，仍然有可能会在接下来的一段时间窗口内认为自己还是处于 Active 状态，这样oldActiveNode和 newActiveNode都处于 Active 状态，都可以对外提供服务。这种情况对于 NameNode 这类对数据一致性要求非常高的系统来说是灾难性的，数据会发生错乱且无法恢复。Zookeeper 社区的应对方案是 fencing(隔离)：把旧的 Active NameNode 隔离，使之不能正常对外提供服务。</p>
<p><strong>ActiveStandbyElector会在选举为主节点时，创建一个持久节点/hadoop-ha/${dfs.nameservices}/ActiveBreadCrumb，这个节点里面保存了这个 Active NameNode 的地址信息</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在选举为主节点时，会创建一个持久节点</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">becomeActive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">assert</span> wantToBeInElection;</span><br><span class="line">  <span class="keyword">if</span> (state == State.ACTIVE) &#123;</span><br><span class="line">    <span class="comment">// already active</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    Stat oldBreadcrumbStat = fenceOldActive();<span class="comment">//回调方法，返回old active node</span></span><br><span class="line">    writeBreadCrumbNode(oldBreadcrumbStat);</span><br><span class="line">    LOG.debug(<span class="string">"Becoming active for &#123;&#125;"</span>, <span class="keyword">this</span>);</span><br><span class="line">    appClient.becomeActive();</span><br><span class="line">    state = State.ACTIVE;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    LOG.warn(<span class="string">"Exception handling the winning of election"</span>, e);</span><br><span class="line">    <span class="comment">// Caller will handle quitting and rejoining the election.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果 breadcrumb node 存在，表明有oldActiveNode需要隔离, 调用ZKFailoverController的方法去隔离,返回stat(非null)，如果breadcrumb node不存在，返回null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Stat <span class="title">fenceOldActive</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, KeeperException </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Stat stat = <span class="keyword">new</span> Stat();</span><br><span class="line">  <span class="keyword">byte</span>[] data;</span><br><span class="line">  LOG.info(<span class="string">"Checking for any old active which needs to be fenced..."</span>);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    data = zkDoWithRetries(<span class="keyword">new</span> ZKAction&lt;<span class="keyword">byte</span>[]&gt;() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">byte</span>[] run() <span class="keyword">throws</span> KeeperException, InterruptedException &#123;</span><br><span class="line">        <span class="keyword">return</span> zkClient.getData(zkBreadCrumbPath, <span class="keyword">false</span>, stat);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (KeeperException ke) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isNodeDoesNotExist(ke.code())) &#123;</span><br><span class="line">      LOG.info(<span class="string">"No old node to fence"</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// If we failed to read for any other reason, then likely we lost</span></span><br><span class="line">    <span class="comment">// our session, or we don't have permissions, etc. In any case,</span></span><br><span class="line">    <span class="comment">// we probably shouldn't become active, and failing the whole</span></span><br><span class="line">    <span class="comment">// thing is the best bet.</span></span><br><span class="line">    <span class="keyword">throw</span> ke;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  LOG.info(<span class="string">"Old node exists: &#123;&#125;"</span>, StringUtils.byteToHexString(data));</span><br><span class="line">  <span class="keyword">if</span> (Arrays.equals(data, appData)) &#123;</span><br><span class="line">    LOG.info(<span class="string">"But old node has our own data, so don't need to fence it."</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    appClient.fenceOldActive(data);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> stat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果old activeNode不存在，创建持久节点；否则更新node</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeBreadCrumbNode</span><span class="params">(Stat oldBreadcrumbStat)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> KeeperException, InterruptedException </span>&#123;</span><br><span class="line">  Preconditions.checkState(appData != <span class="keyword">null</span>, <span class="string">"no appdata"</span>);</span><br><span class="line">  </span><br><span class="line">  LOG.info(<span class="string">"Writing znode &#123;&#125; to indicate that the local "</span> +</span><br><span class="line">      <span class="string">"node is the most recent active..."</span>, zkBreadCrumbPath);</span><br><span class="line">  <span class="keyword">if</span> (oldBreadcrumbStat == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// No previous active, just create the node</span></span><br><span class="line">    createWithRetries(zkBreadCrumbPath, appData, zkAcl,</span><br><span class="line">      CreateMode.PERSISTENT);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    setDataWithRetries(zkBreadCrumbPath, appData, oldBreadcrumbStat.getVersion());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​        </p>
<h2><span id="zkfailovercontroller介绍">ZKFailoverController介绍</span></h2><p>​        主备切换控制器 (ZKFailoverController )作为独立的进程运行，与HealthMonitor 、ActiveStandbyElector两大组件一起对 NameNode 的主备切换进行控制。它启动时，会初始化ActiveStandyElector和healthMonitor,并将回调函数注册进去，当healthMonitor检测到节点状态变化时，利用回调方法通知ZKFailoverController，然后ZKFailoverController使用ActiveStandyElector发起主从选举，当选举结果出来时，ActiveStandyElector将使用注册进去的回调方法通知ZKFailoverController，ZKFailoverController将其转化为Active/Standy Node。</p>
<ol>
<li>ZKFailoverController的初始化时会initZK，构造ActiveStandyElector</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initZK</span><span class="params">()</span> <span class="keyword">throws</span> HadoopIllegalArgumentException, IOException,</span></span><br><span class="line"><span class="function">    KeeperException </span>&#123;</span><br><span class="line">  zkQuorum = conf.get(ZK_QUORUM_KEY);</span><br><span class="line">  <span class="keyword">int</span> zkTimeout = conf.getInt(ZK_SESSION_TIMEOUT_KEY,</span><br><span class="line">      ZK_SESSION_TIMEOUT_DEFAULT);</span><br><span class="line">  <span class="comment">// Parse ACLs from configuration.</span></span><br><span class="line">  String zkAclConf = conf.get(ZK_ACL_KEY, ZK_ACL_DEFAULT);</span><br><span class="line">  zkAclConf = ZKUtil.resolveConfIndirection(zkAclConf);</span><br><span class="line">  List&lt;ACL&gt; zkAcls = ZKUtil.parseACLs(zkAclConf);</span><br><span class="line">  <span class="keyword">if</span> (zkAcls.isEmpty()) &#123;</span><br><span class="line">    zkAcls = Ids.CREATOR_ALL_ACL;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Parse authentication from configuration.</span></span><br><span class="line">  List&lt;ZKAuthInfo&gt; zkAuths = SecurityUtil.getZKAuthInfos(conf, ZK_AUTH_KEY);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Sanity check configuration.</span></span><br><span class="line">  Preconditions.checkArgument(zkQuorum != <span class="keyword">null</span>,</span><br><span class="line">      <span class="string">"Missing required configuration '%s' for ZooKeeper quorum"</span>,</span><br><span class="line">      ZK_QUORUM_KEY);</span><br><span class="line">  Preconditions.checkArgument(zkTimeout &gt; <span class="number">0</span>,</span><br><span class="line">      <span class="string">"In</span></span><br><span class="line"><span class="string">  int maxRetryNum = conf.getInt(</span></span><br><span class="line"><span class="string">      CommonConfigurationKeys.HA_FC_ELECTOR_ZK_OP_RETRIES_KEY,</span></span><br><span class="line"><span class="string">      CommonConfigurationKeys.HA_FC_ELECTOR_ZK_OP_RETRIES_DEFAULT);</span></span><br><span class="line"><span class="string">  elector = new ActiveStandbyElector(zkQuorum,</span></span><br><span class="line"><span class="string">      zkTimeout, getParentZnode(), zkAcls, zkAuths,</span></span><br><span class="line"><span class="string">      new ElectorCallbacks(), maxRetryNum);</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<p>​    <strong>initZK时创建了ActiveStandyElector，并将回调类注册进去，方便ActiveStandyElector监听</strong>，</p>
<ol>
<li>ZKFailoverController的初始化时，会initHealthMonitor</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initHM</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  healthMonitor = <span class="keyword">new</span> HealthMonitor(conf, localTarget);</span><br><span class="line">  healthMonitor.addCallback(<span class="keyword">new</span> HealthCallbacks());</span><br><span class="line">  healthMonitor.addServiceStateCallback(<span class="keyword">new</span> ServiceStateCallBacks());</span><br><span class="line">  healthMonitor.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>initHM时，将回调对象注册进去，当HM监听到状态变化时，利用回调函数通知控制器</li>
<li>当HM执行回调方法enterState（newState）时，控制器使用主从选择器让该节点进入/退出选举</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Callbacks from HealthMonitor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HealthCallbacks</span> <span class="keyword">implements</span> <span class="title">HealthMonitor</span>.<span class="title">Callback</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enteredState</span><span class="params">(HealthMonitor.State newState)</span> </span>&#123;</span><br><span class="line">    setLastHealthState(newState);</span><br><span class="line">    recheckElectability();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Check the current state of the service, and join the election</span></span><br><span class="line"><span class="comment">   * if it should be in the election.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">recheckElectability</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Maintain lock ordering of elector -&gt; ZKFC</span></span><br><span class="line">    <span class="keyword">synchronized</span> (elector) &#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> healthy = lastHealthState == State.SERVICE_HEALTHY;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">long</span> remainingDelay = delayJoiningUntilNanotime - System.nanoTime(); </span><br><span class="line">        <span class="keyword">if</span> (remainingDelay &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (healthy) &#123;</span><br><span class="line">            LOG.info(<span class="string">"Would have joined master election, but this node is "</span> +</span><br><span class="line">                <span class="string">"prohibited from doing so for "</span> +</span><br><span class="line">                TimeUnit.NANOSECONDS.toMillis(remainingDelay) + <span class="string">" more ms"</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          scheduleRecheck(remainingDelay);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">switch</span> (lastHealthState) &#123;</span><br><span class="line">        <span class="keyword">case</span> SERVICE_HEALTHY:</span><br><span class="line">          elector.joinElection(targetToData(localTarget));</span><br><span class="line">          <span class="keyword">if</span> (quitElectionOnBadState) &#123;</span><br><span class="line">            quitElectionOnBadState = <span class="keyword">false</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">          </span><br><span class="line">        <span class="keyword">case</span> INITIALIZING:</span><br><span class="line">          LOG.info(<span class="string">"Ensuring that "</span> + localTarget + <span class="string">" does not "</span> +</span><br><span class="line">              <span class="string">"participate in active master election"</span>);</span><br><span class="line">          elector.quitElection(<span class="keyword">false</span>);</span><br><span class="line">          serviceState = HAServiceState.INITIALIZING;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">case</span> SERVICE_UNHEALTHY:</span><br><span class="line">        <span class="keyword">case</span> SERVICE_NOT_RESPONDING:</span><br><span class="line">          LOG.info(<span class="string">"Quitting master election for "</span> + localTarget +</span><br><span class="line">              <span class="string">" and marking that fencing is necessary"</span>);</span><br><span class="line">          elector.quitElection(<span class="keyword">true</span>);</span><br><span class="line">          serviceState = HAServiceState.INITIALIZING;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">          </span><br><span class="line">        <span class="keyword">case</span> HEALTH_MONITOR_FAILED:</span><br><span class="line">          fatalError(<span class="string">"Health monitor failed!"</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">          </span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unhandled state:"</span></span><br><span class="line">                                               + lastHealthState);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>选举器在选举结束后，会在processXXX（）回调控制器的方法，通知控制器选举完成，然后控制器通过HAServiceProtocol的rpc调用将对应的节点变为主/从节点</p>
<h3><span id="总结">总结</span></h3><p><img src="https://www.ibm.com/developerworks/cn/opensource/os-cn-hadoop-name-node/img002.png" alt="NameNode主从切换的过程"></p>
<p>​                                    <a href="http://www.boren33.com/2018/08/22/NameNode%E4%B8%BB%E5%A4%87%E5%88%87%E6%8D%A2/">图片引自</a></p>
<h3><span id="注意事项">注意事项</span></h3><p>**最后需要注意的是这个选举机制只有当候选节点较少时才有效（order of 10’s），因为大量候选者连接zookeeper的同一个节点会导致zookeeper过载。</p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a class="article-share-link" data-url="http://www.boren33.com/NameNode主备切换.html" data-id="cjl70q9es0002j9v2nyfv2apn" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACNUlEQVR42u3aS47CMBAFQO5/6Yw0q5GYhNdtg4hdXiECcSqLlvvzeMTr+F1/Pz+v56v5Pav/bS4MDIzbMo7Ldc24vlv1FeS//2d3DAyMDRh5kK1+k1y93jcJ1hgYGBgj2yeBFQMDA+OTAXfkuImBgYFxzciLaC+SyZPfV2tlb8zFMTAwbsjoNQY+8/nt/Q0MDIyvZxzFlbcee0X/5lNhYGAszbh+rF57MrlntXkQhWMMDIxFGfktrgNoNUDnbYAoZcXAwNiMUW06Jse7kZcSFeYwMDCWZlQfpTfglSSuEwpzGBgYSzNmdRV6rdBeAlzIyDEwMJZj9I6DeRI73oQoDIdhYGAswUgSy5Ej3ay5iBdxFQMDY2lGL+3sBc3e0bOaBmNgYKzHyAPcSGGuNyZbKORhYGAszagOfo3MOVRf1oTxCwwMjOUY1UJbtbWQp8HJC8XAwNiHkTcXx8cjkm+qDQkMDIx9GNX0tVee6w1SRPtiYGAszZjVdOyloCMN0dNpEQwMjOUY1UGHJPzlY2HVFsLps2FgYGzA6BW8emnwSEXwdHcMDIylGcn2ebKaNCPz4J4fUjEwMNZmHMU1d+RrpNmJgYGxD6P3ENVtCsX9uBVaBmBgYNyckWw8csibdegsJ7EYGBjLMfIgmx/meoMUzcMlBgYGRgyoBuJqdTBqZGJgYGzPyJuds0pmEQYDA2MDRh7m8sNfdcArbz8MldswMDBuyOglkL2xiVnHxAktTAwMjHswfgCAsX+t/QmYkgAAAABJRU5ErkJggg==">分享</a><div class="tags"><a href="/tags/hadoop/">hadoop</a></div><div class="post-nav"><a class="pre" href="/HDFS高可用性介绍.html">HDFS高可用性介绍</a><a class="next" href="/新梦想.html">新梦想</a></div><div id="lv-container" data-id="city" data-uid="MTAyMC8zNTcwNy8xMjI0Mw=="><script>(function(d, s) {
   var j, e = d.getElementsByTagName(s)[0];
   if (typeof LivereTower === 'function') { return; }
   j = d.createElement(s);
   j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
   j.async = true;
   e.parentNode.insertBefore(j, e);
})(document, 'script');
</script></div></div></div></div><div class="pure-u-1 pure-u-md-1-4"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/往事随风/">往事随风</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术人生/">技术人生</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/hadoop/" style="font-size: 15px;">hadoop</a> <a href="/tags/随笔/" style="font-size: 15px;">随笔</a> <a href="/tags/algorithm/" style="font-size: 15px;">algorithm</a> <a href="/tags/IO/" style="font-size: 15px;">IO</a> <a href="/tags/NIO/" style="font-size: 15px;">NIO</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/HDFS高可用性介绍.html">HDFS高可用性介绍</a></li><li class="post-list-item"><a class="post-list-link" href="/NameNode主备切换.html">NameNode主备切换</a></li><li class="post-list-item"><a class="post-list-link" href="/新梦想.html">新梦想</a></li><li class="post-list-item"><a class="post-list-link" href="/简聊JAVA-NIO.html">简聊JAVA NIO</a></li><li class="post-list-item"><a class="post-list-link" href="/给过去的一封信.html">给过去的一封信</a></li><li class="post-list-item"><a class="post-list-link" href="/遇见美丽.html">遇见美丽</a></li><li class="post-list-item"><a class="post-list-link" href="/向左乐观,向右悲观.html">向左乐观,向右悲观</a></li><li class="post-list-item"><a class="post-list-link" href="/排序算法总结.html">排序算法总结</a></li><li class="post-list-item"><a class="post-list-link" href="/人生传.html">人生传</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://tech.meituan.com" title="美团点评技术团队博客" target="_blank">美团点评技术团队博客</a><ul></ul><a href="http://jm.taobao.org" title="阿里中间件团队博客" target="_blank">阿里中间件团队博客</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">boren's blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.2.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.2.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>